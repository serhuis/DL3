###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           12/May/2017  11:22:45
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\ARTON-DL3\soft\current\main.c
#    Command line  =  
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\main.c -lcN
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\List -o
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\Obj --no_unroll
#        --no_inline --no_tbaa --debug -D__MSP430G2553__ -e --double=32
#        --regvar_r4 --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\430\lib\dlib\dl430fn.h" -I ..\ -I .\ -Om
#    List file     =  
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\List\main.lst
#    Object file   =  
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\Obj\main.r43
#
###############################################################################

E:\_ARTON_PROJ\ARTON-DL3\soft\current\main.c
      1          /**********************************************************************************
      2           *
      3           *      ASD-10QR MAIN routine
      4           * 
      5           **********************************************************************************
      6           * FileName:        main.c
      7           * Version:			1.00
      8           *
      9           * Processor:       MSP430G2xxx
     10           * Complier:        IAR Workbench for MSP430 v4.50 or higher
     11           *                  
     12           * Company:         ARTON
     13           *
     14           * Software License Agreement
     15           *
     16           * The software supplied herewith by ARTON Incorporated
     17           * (the "Company") for its devices is intended and
     18           * supplied to you, the Company's customer, for use solely and
     19           * exclusively on ARTON Inc products. The
     20           * software is owned by the Company and/or its Author, and is
     21           * protected under applicable copyright laws. All rights are reserved.
     22           * Any use in violation of the foregoing restrictions may subject the
     23           * user to criminal sanctions under applicable laws, as well as to
     24           * civil liability for the breach of the terms and conditions of this
     25           * license.
     26           *
     27           * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
     28           * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
     29           * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
     30           * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
     31           * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
     32           * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
     33           *
     34           *
     35           * Author               Date      	Version	  		Comment
     36           *--------------------------------------------------------------------------------
     37           * Oleg Semeniuk	 16.01.2014    	1.00		Release for v1.00
     38           *
     39           *********************************************************************************/
     40          
     41          
     42          /*********************************************************************************/
     43          /*                                 INCLUDES                                      */
     44          /*********************************************************************************/
     45          
     46          
     47          #include <stdio.h>                    /* standard I/O .h-file                */
     48          #include <string.h>                   /* string and memory functions         */
     49          
     50          #include  "hardware.h"
     51          #include  "main.h"
     52          #include  "flash.h"
     53          #include  "type.h"
     54          #include  "delay.h"
     55          #include  "soft_uart.h"
     56          
     57          
     58          /*********************************************************************************/
     59          /*                                 VARIABLES                                     */
     60          /*********************************************************************************/
     61          
     62          __regvar __no_init tFlags 	f 	 @ __R4; 	// Set of state machine flags
     63          
     64          //
     65          u16		timerMain;					// Текущее значение главного таймера
     66          u16		timerLongPeriod;			// Таймер для режимa HUSH
     67          u16		mainPeriodCounter;			// Counter of main time period
     68          u16 	timerKeyDown;				// Для отслеживания нажатия на кнопку TEST
     69          u16		adc_data1[ADC_CH_DATA_LEN];	// Array for ADC samples
     70          
     71          u8 		DeviceMode; 				// Mode of device
     72          
     73          tFault	DeviceFault = {0};			// Current Faults flags
     74          tCalibrFault CalibrFault = {0};		// Calibration Faults flags
     75          u16 	dark;						// Level of dark signal
     76          u16 	delta;						// Current level signal
     77          
     78          u16 	delta_last = 0;				// Prev sygnal of delta
     79          u16		zero_timer = 0;				// Zero level signal timer
     80          
     81          u8		fault_chamber_counter = 0;	// Counter of series chamber fault
     82          u8  	FireMeasCount = 0;			// Количество замеров, превышающих порог Пожара
     83          
     84          // Variables for definition Long Term Drift
     85          u16  	DriftCounter = 0;
     86          u32 	DriftSumma = 0;
     87          u32 	DriftLevel;					// Current Long Term Drift Level
     88          	
     89          //u16 	FireLimit;					// Current Limit of Fire
     90          //u16 	PreFireLimit;				// Current Limit of PreFire
     91          	
     92          u16		CCR1_Value;					// CCR1 PWM duty cycle for sound generation
     93          u8 		Timer50msCounter = 0;		// Counter of 50ms ticks
     94          
     95          
     96          s16		signal_array[SIGNAL_ARRAY_LEN];
     97          
     98          //u8		AMP_Off_Timer = 0;
     99          
    100          
    101          volatile u32		led_r;
    102          volatile u32		led_y;
    103          volatile u32		led_sh = 0;
    104          
    105          u8 		fTimerA1_On = 0;
    106          
    107          
    108          #define CALIBR_STAGES		6
    109          u8 		calibr_stage;
    110          u16		s_array[CALIBR_STAGES];
    111          u8		q_array[CALIBR_STAGES];
    112          
    113          
    114          const u8 calibr_sequence[CALIBR_STAGES][3] = {
    115          //			 Amp_No	Gain  Reference
    116          			{  1,    0,     2 },
    117          			{  2,    0,     1 },
    118          //			{  2,    0,     0 },
    119          			{  2,    1,     1 },
    120          			{  2,    2,     1 },
    121          			{  2,    3,     1 },
    122          			{  2,    3,     0 },
    123          };
    124          //
    125          
    126          const u8 fault_sequence[4 * 2] = {MODE_FAULT, 10, MODE_NORM, 10, MODE_FIRE, 0, 0};	// 0 = ~~
    127          
    128          u8  fault_chain_ind = 0;	// 	
    129          u16 fault_chain_timer = 0;
    130          
    131          s8	gain;
    132          u8	amp_no;
    133          u8	reference;
    134          tCfgReg	cfg_reg;
    135          
    136          u8	jp1_state = 1;			// 0 - JP1 Open, 1 - JP1 Close
    137          
    138          u8	adc_process = 0;		// ADC low level semafore
    139          
    140          u16	light_timer = 0;		// For led lighting
    141          u8	light_sync = 0;			// For led lighting syncronisation
    142          
    143          u16	strob_pulse_timer = 0;	// Таймер ожидания электрической синхронизации
    144          u8	strob_fault_phase = 0;	// Фаза неисправности электрической синхронизации 0 - отключение БИ, 1 - включение БИ
    145          
    146          u16	hi_signal_counter  = 0;	// Very Hight signal counter
    147          
    148          u16	fault_timer = 0;		// Fault signal timer
    149          u8  fault_phase  = 0;		// Phase of  fault signal: 1 - break of BI , 0 - enable of  BI	
    150          
    151          u16 start_timer = 0;		// Start timer of device
    152          
    153          u16 flash_period_timer;		// Flast period timer
    154          
    155          u16 PWM_period = 0;
    156          
    157          
    158          
    159          /*********************************************************************************/
    160          /*                                FUNCTIONS                                      */
    161          /*********************************************************************************/
    162          // --- Declarations ---
    163          void ADC_MeasureInit(u8 input_no, u8 refer);
    164          u8   SignalAnalysis(void);
    165          void ADC_MeasureStart(void);
    166          void AMP_Calibration(void);
    167          
    168          u16  AverageData(u16 * data_ptr, u8 len);
    169          u8   RX_PacketParser(void);
    170          void ADC_Measure(u16 ch, u16 refout, u8 count);
    171          
    172          void Timer_A1_Init(void);
    173          void Timer_A0_SetDelay(u16 period);
    174          void Timer_A0_Off(void);
    175          void JP1_Define(void);
    176          
    177          
    178          
    179          
    180          //--------------------------------------------------------------------------------
    181          // Function		: void VLO_TimerCalibr(void)
    182          // Parameters	: None
    183          // Return		: None
    184          // Description	: Calculation calibration value of VLO timer
    185          //--------------------------------------------------------------------------------
    186          void VLO_TimerCalibr(void) {
    187          	u16 clk;
    188          	
    189          	// Start timer 1MHz
    190          	TACTL = TASSEL_2 + MC_1 + ID_3;     	 	// SMCLK, up mode  / 8
    191          	//			
    192          	CCR0 = 62500 - 1;	                    // Period 0.5sec
    193          	CCTL1 = 0; 			                    // CCR1 reset/set
    194          	TACCTL0 = CCIE;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    195          	//
    196          	clk = 0;
    197          	while (1) {
    198          		if (fTimer50msOn) {
    199          			fTimer50msOn = 0;
    200          			clk++;
    201          		}
    202          		if (fTimerA_On) {
    203          			fTimerA_On = 0;
    204          			clk++;
    205          			break;
    206          		}
    207          	}
    208          	//
    209          	//SoundStop();							// Disable interrupts of timer
    210          	TACTL = 0;  
    211          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    212          	//
    213          	if (clk != CONFIG->timer_calibr) {
    214          		StoragePropertyWord(eeTIMER_CALIBR_OFFSET, clk * 2);
    215          		#if (CRC_ENABLE == 1)
    216          		SavePropertyCS();
    217          		#endif
    218          	}
    219          	//
    220          }
    221          
    222          
    223          //--------------------------------------------------------------------------------
    224          // Function		: void ClearDriftVar(void)
    225          // Parameters	: None
    226          // Return		: None
    227          // Description	: Clear Long Term Drift variables
    228          //--------------------------------------------------------------------------------
    229          void ClearDriftVar(void) {
    230          	DriftCounter = 0;
    231          	DriftSumma = 0;
    232          	DriftLevel = 0;
    233          }
    234          
    235          
    236          
    237          //--------------------------------------------------------------------------------
    238          // Function		: void SetLimitCompens(void)
    239          // Parameters	: fire_level - fire level in increment
    240          // Return		: None
    241          // Description	: Setting limit compensation level
    242          //--------------------------------------------------------------------------------
    243          void SetLimitCompens(void) {
    244          	u16 norm = CONFIG->limit_norm;
    245          	//
    246          	StoragePropertyWord(eeLIMIT_LONG_DRIFT_OFFSET, norm / 2);
    247          	//
    248          #if (CRC_ENABLE == 1)
    249          	SavePropertyCS();
    250          #endif
    251          	//
    252          	ClearDriftVar();
    253          	//
    254          }
    255          
    256          
    257          
    258          //--------------------------------------------------------------------------------
    259          // Function		: void SetLevels(u16 norm)
    260          // Parameters	: norm - norm sygnal level 
    261          // Return		: None
    262          // Description	: Calculation and setting levels depending on background signal
    263          //--------------------------------------------------------------------------------
    264          void SetLevels(u16 norm) {
    265          	u16 temp;
    266          	u8  d;	
    267          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    268          	//
    269          	d = norm * 28 / 100;
    270          	//
    271          	temp = norm - d;		//
    272          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    273          	//
    274          	temp = norm - d * 3 / 4;		//
    275          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    276          	
    277          	//
    278          #if (CRC_ENABLE == 1)
    279          	SavePropertyCS();
    280          #endif
    281          	//
    282          	ClearDriftVar();
    283          	//
    284          }
    285          
    286          
    287          
    288          //--------------------------------------------------------------------------------
    289          // Function		: void SetLevels(u16 norm)
    290          // Parameters	: norm - norm sygnal level, nonlinearity_corr - correction 
    291          //				  nonlinearity in case of Hi signal (0 - none, 1 - low correction,
    292          //				  2 - hi correction)
    293          // Return		: None
    294          // Description	: Calculation and setting levels depending on background signal
    295          //--------------------------------------------------------------------------------
    296          void SetLevelsFromCalibr(u16 norm, u8 nonlinearity_corr) {
    297          	u16 temp;
    298          	u16  d;	
    299          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    300          	//
    301          	switch (nonlinearity_corr) {
    302          		case 0:
    303          			d = norm * 29 / 100;
    304          			break;
    305          		case 1:
    306          			d = norm * 23 / 100;
    307          
    308          			
    309          			break;
    310          		case 2:
    311          			d = norm * 18 / 100;
    312          			break;
    313          		default:
    314          			d = norm * 29 / 100;
    315          	}
    316          	//
    317          	temp = norm - d;		//
    318          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    319          	//
    320          	temp = norm - d * 3 / 4;		//
    321          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    322          	
    323          	//
    324          #if (CRC_ENABLE == 1)
    325          	SavePropertyCS();
    326          #endif
    327          	//
    328          	ClearDriftVar();
    329          	//
    330          }
    331          
    332          
    333          
    334          //--------------------------------------------------------------------------------
    335          // Function		: void DeviceStart(void)
    336          // Parameters	: None
    337          // Return		: None
    338          // Description	: Function executes initialization variable at start of device
    339          //--------------------------------------------------------------------------------
    340          void DeviceStart(void) {
    341          
    342          	DeviceFault.byte = 0;		// Reset faults flags
    343          	CalibrFault.byte = 0;		// Reset faults flags
    344          	//		
    345          	VLO_TimerCalibr();			// Calibration VLO Timer
    346          	//
    347          	ClearDriftVar();
    348          	
    349          }
    350          
    351          
    352          //--------------------------------------------------------------------------------
    353          // Function		: void DefineFireLimit(void)
    354          // Parameters	: None
    355          // Return		: None
    356          // Description	: Determination fire and prefire limits depending on long term drift
    357          //--------------------------------------------------------------------------------
    358          //#pragma optimize=none
    359          u16 getZeroLevel(void) {
    360          	u16 ret;
    361          	//
    362          //attenuation is more then 6dB (25%)
    363          //        ret = CONFIG->limit_norm >> 2;
    364          
    365          //attenuation is more then 7dB (20%)
    366          	ret = CONFIG->limit_norm / 5;                   
    367          
    368          //attenuation is more then ~7.7dB (17%)
    369          //	ret = CONFIG->limit_norm / 6;
    370          
    371          	return ret;
    372          }
    373          
    374          
    375          //--------------------------------------------------------------------------------
    376          // Function		: u16 getTimerValue(u16 period_sec)
    377          // Parameters	: time_sec : time in sec (0..655)
    378          // Return		: None
    379          // Description	: Getting time in system ticks
    380          //--------------------------------------------------------------------------------
    381          static u16 getTimerValue(u16 time_sec) {
    382          	u16 time = 100;
    383          	
    384          	if (time_sec > 655) return 0;
    385          	
    386          	time *= time_sec;	
    387          	
    388          	return time;
    389          
    390          }
    391          
    392          
    393          //--------------------------------------------------------------------------------
    394          // Function		: void VLO_TimerCalibr(void)
    395          // Parameters	: None
    396          // Return		: None
    397          // Description	: Calculation calibration value of VLO timer
    398          //--------------------------------------------------------------------------------
    399          u16 VLO_GetPeriod(void) {
    400          	
    401          	// Start timer 8MHz
    402          	TACTL = TASSEL_2 + MC_1;           	 	// SMCLK, up mode
    403          	//			
    404          	CCR0 =0xFFFF;                    		// Period 2.5mS
    405          	CCTL1 = 0; 			                    // CCR1 reset/set
    406          	TACCTL0 = 0;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    407          	//
    408          	while (fTimer50msOn == 0) {}
    409          	fTimer50msOn = 0;
    410          	//while (fTimer50msOn == 0) {}
    411          	
    412          	return TAR;
    413          	
    414          }
    415          
    416          
    417          //--------------------------------------------------------------------------------
    418          // Function		: void VLO_TimerCalibr(void)
    419          // Parameters	: None
    420          // Return		: None
    421          // Description	: Calculation calibration value of VLO timer
    422          //--------------------------------------------------------------------------------
    423          void AMP_Gain_Init(void) {
    424          	
    425          	AMP_SetGain(CONFIG->Gain);
    426          	
    427          }
    428          
    429          #define ADC_AMP1	INCH_1		/* First AMP out */
    430          #define ADC_AMP2	INCH_0		/* Second AMP out */
    431          #define ADC_BUT		INCH_2		/* Tact button */
    432          #define ADC_AE		0x13		/* Analog (Input) Enable Control Register Value + VREF+*/
    433          #define ADC_AE_BUT	0x17		/* Analog (Input) Enable Control Register Value + Tact sw + VREF+*/
    434          
    435          #define ADC_FLUCTATION			20
    436          #define SIGNAL_0_LEVEL			512
    437          
    438          #define CORREL_LEVEL			120		/* Threshold level to correlations of the start signal */
    439          
    440          
    441          
    442          //--------------------------------------------------------------------------------
    443          // Function		: ADC_Measure(u8 input_no, u8 refer)
    444          // Parameters	: input_no - number AMP output (= 1 or 2), refer - reference voltage (=0 - 1.5V, =1 - 2.5V, =2 - 3.3V)
    445          // Return		: None
    446          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    447          //				   ~109 kS/s for 16 MHz 
    448          //--------------------------------------------------------------------------------
    449          void ADC_MeasureInit(u8 input_no, u8 refer) {
    450          	
    451          	ADC10CTL0 &= ~ENC;
    452          	while (ADC10CTL1 & BUSY);             	// Wait if ADC10 core is active 
    453          	//
    454          	switch ((Ref_Type)refer) {
    455          		case REF_1_5V:  
    456          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE;				// Sample&hold = 8 x ADC10CLKs
    457          			break;
    458          		case REF_2_5V:  
    459          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    460          			break;
    461          		case REF_3_3V:  
    462          			ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC + ADC10ON + ADC10IE  + REFOUT + REFON + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    463          			break;
    464          	}
    465          	//
    466          	DelayUs(50);	
    467          	//
    468          	ADC10DTC1 = SIGNAL_ARRAY_LEN;	//ADC_SAMPLES_NUMBER;			// count of conversions
    469          	//
    470          	if (input_no == 1) {
    471          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP1;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 1
    472          	}else{
    473          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP2;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 2
    474          	}
    475          	
    476          	ADC10AE0 |= ADC_AE;                     // A0 & A1 ADC option select
    477          	//
    478          }
    479          
    480          
    481          //--------------------------------------------------------------------------------
    482          // Function		: ADC_Measure(u16 ch, u16 refout, u8 count)
    483          // Parameters	: ch - ADC channel, refout - 0 or REFOUT, count - кол-во измерений 
    484          // Return		: None
    485          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    486          //--------------------------------------------------------------------------------
    487          void ADC_MeasureStart(void) {
    488          	__disable_interrupt();		// Disable interrupt
    489          	
    490          	adc_process = 1;
    491          	
    492          	//ADC10SA = (u16) &signal_array[SIGNAL_ARRAY_LEN - ADC_SAMPLES_NUMBER];      	// Data buffer start - end of sygnal_array
    493          	ADC10SA = (u16) &signal_array[0];	// Data buffer start - end of sygnal_array
    494          	ADC10CTL0 |= ENC + ADC10SC;         // Sampling and conversion start
    495          	//
    496          
    497          	__enable_interrupt();                     // enable interrupts
    498          }
    499          
    500          u16 last_0_level;
    501          u16 last_level;
    502          
    503          //--------------------------------------------------------------------------------
    504          // Function		: void VLO_TimerCalibr(void)
    505          // Parameters	: None
    506          // Return		: 0 - no valid array, 1
    507          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    508          //--------------------------------------------------------------------------------
    509          u16 AbsValue(u16 x1, u16 x2) {
    510          	if (x1 >= x2) {
    511          		return (x1 - x2);
    512          	}else{
    513          		return (x2 - x1);
    514          	}
    515          }
    516          
    517          /**************************************************************
    518          WinFilter version 0.8
    519          http://www.winfilter.20m.com
    520          akundert@hotmail.com
    521          
    522          Filter type: Band Pass
    523          Filter model: Butterworth
    524          Filter order: 8
    525          Sampling Frequency: 109 KHz
    526          Fc1 and Fc2 Frequencies: 3.800000 KHz and 14.000000 KHz
    527          Coefficents Quantization: 8-bit
    528          
    529          Z domain Zeros
    530          z = -1.000000 + j 0.000000
    531          z = -1.000000 + j 0.000000
    532          z = -1.000000 + j 0.000000
    533          z = -1.000000 + j 0.000000
    534          z = -1.000000 + j 0.000000
    535          z = -1.000000 + j 0.000000
    536          z = -1.000000 + j 0.000000
    537          z = -1.000000 + j 0.000000
    538          z = 1.000000 + j 0.000000
    539          z = 1.000000 + j 0.000000
    540          z = 1.000000 + j 0.000000
    541          z = 1.000000 + j 0.000000
    542          z = 1.000000 + j 0.000000
    543          z = 1.000000 + j 0.000000
    544          z = 1.000000 + j 0.000000
    545          z = 1.000000 + j 0.000000
    546          
    547          Z domain Poles
    548          z = 0.644814 + j -0.260807
    549          z = 0.644814 + j 0.260807
    550          z = 0.756494 + j -0.196546
    551          z = 0.756494 + j 0.196546
    552          z = 0.587475 + j -0.386644
    553          z = 0.587475 + j 0.386644
    554          z = 0.840396 + j -0.195195
    555          z = 0.840396 + j 0.195195
    556          z = 0.588237 + j -0.523443
    557          z = 0.588237 + j 0.523443
    558          z = 0.901607 + j -0.202202
    559          z = 0.901607 + j 0.202202
    560          z = 0.951542 + j -0.212108
    561          z = 0.951542 + j 0.212108
    562          z = 0.642148 + j -0.658914
    563          z = 0.642148 + j 0.658914
    564          ***************************************************************/
    565          
    566          #define Ntap 18
    567          
    568          // !!! See division by DCgain below
    569          #define DCgain 512	
    570          
    571          //const s16 FIRCoef[Ntap] = { 
    572          const s8 FIRCoef[Ntap] = { 
    573                    -13,
    574                    -32,
    575                    -52,
    576                    -59,
    577                    -43,
    578                     -2,
    579                     50,
    580                     95,
    581                    113,
    582                     95,
    583                     50,
    584                     -2,
    585                    -43,
    586                    -59,
    587                    -52,
    588                    -32,
    589                    -13,
    590                     -3
    591          };
    592          
    593          
    594          static s16 	x[Ntap] = {0};	//, 512, 512, 512 }; 	//input samples
    595          
    596          s16 fir_filter(s16 sample) {
    597              s32	 		y = 0;      //output sample
    598              int 		i;
    599          	
    600              // Shift the old samples
    601          __disable_interrupt();
    602              for(i = Ntap-1; i > 0; i--) {
    603          		x[i] = x[i-1];
    604          	}
    605          	
    606              // Calculate the new output
    607              x[0] = sample;
    608              for(i = 0; i < Ntap; i++) {
    609          		y += (s32)FIRCoef[i] * x[i];
    610          	}
    611          	
    612          	if (y >= 0) {
    613          		y = y >> 9;
    614          	}else{
    615          		y = y / DCgain;	
    616          	}
    617          __enable_interrupt();	
    618              return y;	// / DCgain;
    619          }
    620          
    621          
    622          //s16	adc_back1[ADC_SAMPLES_NUMBER];
    623          
    624          volatile s16	d1, d2, d3, d4;
    625          
    626          #define EXT_ARRAY_LEN	7
    627          
    628          //--------------------------------------------------------------------------------
    629          // Function		: void VLO_TimerCalibr(void)
    630          // Parameters	: None
    631          // Return		: 0 - no signal, 1 - signal is existing
    632          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    633          //--------------------------------------------------------------------------------
    634          //#pragma optimize=none
    635          u8 SignalAnalysis(void) {
    636          	int i;
    637          	s16	sample;
    638          	s16 min = 2048, max = -2048;
    639          	int i_min = 0, i_max = 0;
    640          	u8 array_hi[EXT_ARRAY_LEN];
    641          	u8 array_lo[EXT_ARRAY_LEN];
    642          	u8 i_hi = 0;
    643          	u8 i_lo = 0;
    644          	s8 T = 0;
    645          	u8 ret = 0;
    646          	
    647          	// 
    648              for(i = 1; i < Ntap; i++) {
    649          		x[i] = 0;	//signal_array[i] - 220;
    650          	}
    651          	
    652          	sample = AverageData((u16 *)&signal_array[0], 16);
    653          	
    654          	// Filtering with use FIR
    655          	for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
    656          		//signal_array[i] = fir_filter(adc_data1[j++] - 512);
    657          		signal_array[i] = fir_filter(signal_array[i] - sample);	
    658          	}
    659          	
    660          	
    661          	// Searching for of importance of the amplitude of the signal on possible gap of time
    662          	for (i = 10; i < SIGNAL_ARRAY_LEN - 2; i++) {
    663          		sample = signal_array[i];
    664          		if (((sample >  signal_array[i - 1]) && (sample >  signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) ||
    665          		    ((sample >  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) || 
    666          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) )   {
    667          	
    668          			if (sample > 10) {	
    669          				array_hi[i_hi] = i;
    670          				if (i_hi < EXT_ARRAY_LEN - 1) i_hi++;
    671          			}
    672          			
    673          			
    674          		}
    675          		
    676          		if (((sample <  signal_array[i - 1]) && (sample <  signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) ||
    677          		    ((sample <  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) || 
    678          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) )   {
    679          		
    680          			if (sample < (-10)) {	
    681          				array_lo[i_lo] = i;
    682          				if (i_lo < EXT_ARRAY_LEN - 1) i_lo++;
    683          			}
    684          			
    685          		}
    686          			
    687          		if (sample < min) {
    688          			min = sample;
    689          			i_min = i;
    690          		}
    691          		if (sample > max) {
    692          			max = sample;
    693          			i_max = i;
    694          		}
    695          	}
    696          
    697          	//
    698          	delta = 0;
    699          	
    700          	if ((i_lo < 2) || (i_hi < 3)) {
    701          		// Low signal
    702          		ret = 1;
    703          	}else{
    704          		T = array_hi[1] - array_hi[0];
    705          		if ((T < 9) || (T > 15))  {
    706          			// High signal
    707          			ret = 2;
    708          		}
    709          	}
    710          	
    711          	d1 = signal_array[array_hi[0]] - signal_array[array_hi[1]];
    712          	if (((d1 < -50) || (d1 > 50)) && (amp_no == 1)){
    713          		// Wery high signal
    714          		ret = 2;
    715          	}
    716          	
    717          	// Definition of delta
    718          	// Define of first low extremum after first hi extremum
    719          	for (i = 0; i < EXT_ARRAY_LEN; i++) {
    720          		if (array_lo[i] > array_hi[0]) {
    721          			i_hi = 0;
    722          			i_lo = i;
    723          			break;
    724          		}
    725          	}
    726          	//
    727          	/* ////
    728          	i_hi++;
    729          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo++]];
    730          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    731          	delta = (d1 + d2) / 2;
    732          	*/
    733          	
    734          	//i_lo++;
    735          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    736          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo++]];
    737          	d3 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    738          	d4 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    739          
    740          	delta = (d1 + d2 + d3 + d4) / 4;
    741          	
    742          	if (delta > 4000) {
    743          		delta = 0;	//CONFIG->limit_norm;
    744          	}
    745          	
    746          	if ((DeviceMode == MODE_CALIBR) && ret) {
    747          		delta = 0;
    748          	}
    749          	//
    750          //DL3
    751                  PWM_period = delta;
    752          //end DL3
    753          	return ret;
    754          }
    755          
    756          
    757          
    758          //--------------------------------------------------------------------------------
    759          // Function		: void Timer_A0_SetDelay(u16 period)
    760          // Parameters	: period in us (1..65535) - for 8 MHz DCO
    761          // Return		: None
    762          // Description	: Function initiates delay
    763          //--------------------------------------------------------------------------------
    764          void Timer_A0_SetDelay(u16 period) {
    765          	
    766          	if (period == 0) return;
    767          	
    768          	_BIC_SR(GIE);    					// Запрещаем прерывания
    769          	
    770          	fTimerA_Enable = 1;
    771          	fTimerA_Repeat = 0;
    772          	//
    773          	TA0R = 0;
    774          	TACTL 	 = TASSEL_2 + MC_1 + ID_3;  // SMCLK, up mode, div = 8
    775          	CCR0 	 = period - 1;      		// Period T(us) * F(MHz)
    776                  CCR1 	 = 0;      		// Period T(us) * F(MHz)
    777          	TACCTL0 = CCIE;						// Разрешаем прерывание таймера по достижению значения TACCCR0.
    778          	//
    779          	_BIS_SR(GIE);    					// Разрешаем прерывания
    780          }
    781          //--------------------------------------------------------------------------------
    782          // Function		: void Timer_A0_StartPWM(u16 PulseWidth)
    783          // Parameters	: PulseWidth in us (1..65535) - for 8 MHz DCO
    784          // Return		: None
    785          // Description	: Function initiates PWM 
    786          //--------------------------------------------------------------------------------
    787          #define PWM_PWRIOD      1024
    788          void Timer_A0_StartPWM(u16 PulseWidth){	
    789            u16 tmp = PWM_PWRIOD/PulseWidth;
    790            
    791            if ((PulseWidth == 0) || (f.bTimerA_On == 1) || (f.bTimerA_Repeat ==1))return;
    792          
    793          	
    794          	_BIC_SR(GIE);    					// Запрещаем прерывания
    795          
    796                  P1SEL |= TEST_OUT_BIT;
    797                  
    798                  if (BCSCTL1 == CALBC1_8MHZ)
    799                    TACTL = TASSEL_2 + MC_1 + ID_3;      // SMCLK, up mode, div = 8
    800                  else
    801                    if(BCSCTL1 == CALBC1_1MHZ)
    802                      TACTL = TASSEL_2 + MC_1;            // SMCLK, up mode, div = 1
    803          
    804          	TACCTL1 = OUTMOD_7;
    805          //        CCR0 	 = PWM_PWRIOD - 1;
    806          //        CCR1 	 = PulseWidth - 1;      		// Period T(us) * F(MHz)
    807                    CCR1 	 = CCR0/tmp;      		// Period T(us) * F(MHz)
    808          
    809                  
    810                  
    811                  
    812                  //	TACCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
    813          //        TACCTL1 = CCIE;				// Разрешаем прерывание таймера по достижению значения TACCCR1.
    814                    //
    815                  _BIS_SR(GIE);    				// Разрешаем прерывания
    816          }
    817          void Timer_A0_StopPWM(void){	
    818          	_BIC_SR(GIE);    				// Запрещаем прерывания
    819          	
    820                  P1SEL &= ~TEST_OUT_BIT;
    821                  TEST_OUT_CLR();
    822                  
    823                  CCR0 	 = 0;
    824          
    825                  fPWMEnabled = 0;
    826          
    827                  _BIS_SR(GIE);    					// Разрешаем прерывания
    828          }
    829          void Timer_A0_SetPWMPulse(u16 Pulse){	
    830            
    831          	if (Pulse == 0) return;
    832          	
    833          	_BIC_SR(GIE);    					// Запрещаем прерывания
    834                  CCR0 	 = PWM_PWRIOD - 1;
    835                  CCR1 	 = Pulse - 1;      		// Period T(us) * F(MHz)
    836          	//
    837          	_BIS_SR(GIE);    					// Разрешаем прерывания
    838          }
    839          
    840          //--------------------------------------------------------------------------------
    841          // Function		: void TimerA1_DelayUs(u16 time)
    842          // Parameters	: period in us (1..32768) - for 1 MHz DCO
    843          // Return		: None
    844          // Description	: Function initiates 
    845          //--------------------------------------------------------------------------------
    846          #pragma optimize=none
    847          void TimerA1_DelayUs(u16 time) {
    848          	_BIC_SR(GIE);    					// Запрещаем прерывания
    849          	
    850          	//
    851          	TA1R = 0;
    852          	TA1CTL 	 = TASSEL_2 + MC_1;     	// SMCLK, up mode, div = 8
    853          	TA1CCR0 	 = time - 1 - 35;      	// Period T(us) * F(MHz)
    854          	//
    855          	_BIS_SR(GIE);    					// Разрешаем прерывания
    856          	
    857          	while ((TA1CCTL0 & CCIFG) == 0);
    858          	
    859          	TA1CTL 	 = 0;
    860          	TA1CCTL0 = 0;
    861          
    862          }
    863          
    864          
    865          //--------------------------------------------------------------------------------
    866          // Function		: void Timer_A1_Init(void)
    867          // Parameters	: period in us (1..65535) - for 1 MHz DCO
    868          // Return		: None
    869          // Description	: Function initiates delay
    870          //--------------------------------------------------------------------------------
    871          void Timer_A1_Init(void) {
    872          	_BIC_SR(GIE);    					// Запрещаем прерывания
    873          	//
    874          	TA1R = 0;
    875          	TA1CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    876          	TA1CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    877          	TA1CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
    878          	//
    879          	_BIS_SR(GIE);    					// Разрешаем прерывания
    880          }
    881          
    882          
    883          //--------------------------------------------------------------------------------
    884          // Function		: void SoundStart(u8 snd_ind)
    885          // Parameters	: period in us (1..32768) - for 16 MHz DCO
    886          // Return		: None
    887          // Description	: Function initiates 
    888          //--------------------------------------------------------------------------------
    889          void Timer_A0_Off(void) {
    890          	_BIC_SR(GIE);    			// Запрещаем прерывания
    891          	//	
    892          	fTimerA_Enable = 0;
    893          	fTimerA_Repeat = 0;
    894          	//
    895                  P1SEL &= ~TEST_OUT_BIT;
    896                  TEST_OUT_CLR();
    897                  
    898          	TACTL = 0;  
    899          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    900          	//
    901          	_BIS_SR(GIE);    			// Разрешаем прерывания
    902          
    903          }
    904          
    905          
    906          //--------------------------------------------------------------------------------
    907          // Function		: void SetFaultMode(void)
    908          // Parameters	: None
    909          // Return		: None
    910          // Description	: 
    911          //--------------------------------------------------------------------------------
    912          void SetFaultMode(void) {
    913          	
    914          	DeviceMode = MODE_FAULT;
    915          	//
    916          
    917          	if (fault_timer == 0) { 
    918          		// No faults
    919          		fault_timer = 1000;		// 10 sec
    920          		fault_phase = 1;		// Break of BI
    921          	}
    922          
    923          	//
    924          //	strob_pulse_timer = 0;		// Clear strob timer because there is breaking BI
    925          }
    926          
    927          
    928          
    929          //--------------------------------------------------------------------------------
    930          // Function		: void FaultSignalManager(void)
    931          // Parameters	: None
    932          // Return		: None
    933          // Description	: Call one time per 10 ms
    934          //--------------------------------------------------------------------------------
    935          void FaultSignalManager(void) {
    936          	
    937          	if ((DeviceMode == MODE_FIRE) || (DeviceMode == MODE_TEST) || (DeviceMode == MODE_CALIBR)) {
    938          		return;
    939          	}
    940          	//
    941          	if (DeviceFault.byte) {
    942          		DeviceMode = MODE_FAULT;
    943          		led_r = 0;
    944          /*		
    945          		if (DeviceFault.fStrobNone) {
    946          			// Electrical sync is fault
    947          			led_y = LED_PULSE_2;
    948          		}else
    949          */
    950                            if (DeviceFault.fSignal_Low) {
    951          			// Level signal is very low
    952          			led_y = LED_PULSE_1;
    953          		}else	
    954          		if (DeviceFault.fFaultDrift) {
    955          			// Long Term Drift fault
    956          			led_y = LED_PULSE_3;
    957          		}else	
    958          		if (DeviceFault.fSignal_Hi) {
    959          			// Level signal is very big
    960          			led_y = LED_PULSE_5;
    961          		}
    962          		
    963          	}
    964          	
    965          	if (CalibrFault.byte) {
    966          		// Calibration fault signals
    967          		
    968          		DeviceMode = MODE_FAULT;
    969          		led_r = 0;
    970          		
    971          		if (CalibrFault.fCalibr_Low) {
    972          			led_y = LED_PULSE_4;
    973          		}else
    974          		if (CalibrFault.fCalibr_Hi) {
    975          			led_y = LED_PULSE_5;
    976          		}
    977          
    978          //DL3		TO BE DONE...
    979          //		BREAK_ENABLE();				// Disable of BI
    980          
    981          		//FIRE_CLR();					// Disable Fire current consumption
    982          //                NFAULT_CLR();
    983          //DL3
    984                            //
    985          		fault_timer = 0;
    986          		fault_phase = 0;
    987          	}
    988          		
    989          	if ((DeviceFault.byte == 0) && (CalibrFault.byte == 0)) {
    990          		if (DeviceMode == MODE_FAULT) {
    991          			DeviceMode = MODE_NORM;
    992          			
    993          			led_r = 0;
    994          			led_y = 0;
    995          			
    996          			fault_timer = 0;
    997          			fault_phase = 0;
    998          /*DL3			
    999          			strob_pulse_timer = 0;
   1000          
   1001          			BREAK_DISABLE();		// Enable of BI
   1002          
   1003          			FIRE_CLR();				// Disable Fire current consumption
   1004          */
   1005          //DL3   
   1006                                  NFAULT_SET();
   1007          //                        fPWMEnabled = 0;
   1008          //DL3   	
   1009          
   1010          		}
   1011          	}
   1012          	//
   1013          
   1014          	if (fault_timer) {
   1015          		fault_timer--;
   1016          		//
   1017          		if (fault_timer == 0) {
   1018          			if (fault_phase) {
   1019          				fault_phase = 0;
   1020          				fault_timer = 2000;		// 20 sec
   1021          			}else{
   1022          				fault_phase = 1;
   1023          				fault_timer = 1000;		// 10 sec
   1024          			}
   1025          		}
   1026          		//
   1027          		if (fault_phase == 1) {
   1028          //DL3			BREAK_ENABLE();			// Disable of BI
   1029                                  NFAULT_CLR();
   1030          		}else{
   1031          //DL3			BREAK_DISABLE();		// Enable of BI
   1032                                  NFAULT_SET();
   1033          		}
   1034          
   1035          	}
   1036                  
   1037          
   1038          }
   1039          
   1040          
   1041          //--------------------------------------------------------------------------------
   1042          // Function		: void LedTestValueManager(void)
   1043          // Parameters	: None
   1044          // Return		: None
   1045          // Description	: 
   1046          //--------------------------------------------------------------------------------
   1047          //#pragma optimize=none
   1048          void LedTestValueManager(void) {
   1049          	if (delta < 150) {
   1050          		led_r = LED_PULSE_1;
   1051          		led_y = LED_FULL;
   1052          	}else
   1053          	if (delta < 250) {
   1054          		led_r = LED_PULSE_2;
   1055          		led_y = LED_FULL;
   1056          	}else
   1057          	if (delta < 450) {
   1058          		led_r = LED_PULSE_3;
   1059          		led_y = LED_FULL;
   1060          	}else
   1061          	if (delta < 550) {
   1062          		led_r = LED_PULSE_4;
   1063          		led_y = LED_FULL;
   1064          	}else{
   1065          		led_r = LED_PULSE_5;
   1066          		led_y = LED_FULL;
   1067          	}
   1068          }
   1069          
   1070          
   1071          //---------------------------------------------------------------------------------
   1072          // Function		: void AMP_SetGain(u8 value)
   1073          // Parameters	: None
   1074          // Return		: None
   1075          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1076          //---------------------------------------------------------------------------------
   1077          void ADC_SetParam(void) {
   1078          	
   1079          	gain = CONFIG->Gain & 0x0F;
   1080          	reference = CONFIG->Gain >> 4;
   1081          	amp_no = CONFIG->AMP_No;
   1082          	
   1083          }
   1084          
   1085          //---------------------------------------------------------------------------------
   1086          // Function		: void AMP_SetGain(u8 value)
   1087          // Parameters	: None
   1088          // Return		: None
   1089          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1090          //---------------------------------------------------------------------------------
   1091          #pragma optimize=none
   1092          void CalibrationResultAnalise(void) {
   1093          	int i;
   1094          	u16 prev, temp, min = 0xFFFF, max = 0;
   1095          	u8  i_ok = 0xFF, i_ok2 = 0xFF;
   1096          	u8  fault = 0;
   1097          	u16 d;
   1098          	u8  corr = 0;
   1099          	
   1100          	prev = s_array[0];
   1101          	for (i = 0; i < CALIBR_STAGES; i++) {
   1102          		temp = s_array[i];
   1103          		//
   1104          		if (temp > max) {
   1105          			max = temp;
   1106          		}
   1107          		if (temp < min) {
   1108          			min = temp;
   1109          		}
   1110          			
   1111          		if (((temp >= 90) && (temp <= 200)) || 
   1112          			((temp >= 480) && (temp <= 600))) {
   1113          			i_ok = i;
   1114          			break;
   1115          		}
   1116          		if ((temp >= 200) && (temp <= 480)) {
   1117          			i_ok2 = i;
   1118          			break;
   1119          		}
   1120          		//
   1121          		if ((prev > 100) && (temp == 0) && (i <= 4)) {
   1122          			fault = 1;	// Signal is vefy Hi
   1123          		}
   1124          		prev = temp;
   1125          	}
   1126          	//
   1127          	if (q_array[0] == 2) {
   1128          		// Signal is vefy Hi
   1129          		fault = 1;
   1130          	}
   1131          	//
   1132          		
   1133          	if (fault) {
   1134          		// End of calibration - very Hi signal - ERROR
   1135          		//DeviceFault.fSignal_Hi = 1;
   1136          		//DeviceMode = MODE_FAULT;
   1137          		CalibrFault.fCalibr_Hi = 1;
   1138          	}else
   1139          	if ((i_ok2 < CALIBR_STAGES) || (i_ok < CALIBR_STAGES)) {
   1140          		if (i_ok2 < CALIBR_STAGES) {
   1141          			i = i_ok2; 
   1142          		}else{
   1143          			i = i_ok;
   1144          		}
   1145          		//
   1146          		// Calibration Ok!!!
   1147          		//
   1148          		d = s_array[i];
   1149          		//q = q_array[i]; 
   1150          		//
   1151          
   1152          	
   1153          		if (i == 0) {
   1154          			if (d >= 480) {
   1155          				CalibrFault.fCalibr_Hi = 1;
   1156          				StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1157          				return;
   1158          			}
   1159          			//
   1160          
   1161          			if (d >= 330) {
   1162          				corr = 2;
   1163          			}else
   1164          			if (d >= 170) {
   1165          				corr = 1;
   1166          			}
   1167          
   1168          		}
   1169          /*
   1170          			if (CALIBR_STAGES - 2 <= i)
   1171          		{
   1172          			corr = 1;
   1173          		}
   1174          	*/		
   1175          		// That's Ok
   1176          		//SetLevels(d);
   1177          		SetLevelsFromCalibr(d, corr);
   1178          		SetLimitCompens();
   1179          		
   1180          		amp_no = calibr_sequence[i][0];
   1181          		gain = calibr_sequence[i][1];
   1182          		reference = calibr_sequence[i][2];
   1183          		
   1184          		StoragePropertyByte(ee_GAIN, gain + (reference << 4));
   1185          		StoragePropertyByte(ee_AMP_NO, amp_no);
   1186          		StoragePropertyWord(eeCONFIG_REG_OFFSET, cfg_reg.word);
   1187          		//
   1188          		DeviceMode = MODE_NORM;
   1189          		//...
   1190          //DL3   
   1191          		//FIRE_CLR();				// Disable Fire current consumption
   1192                          NFAULT_SET();
   1193          //                fPWMEnabled = 0;
   1194          //DL3   	
   1195          
   1196          		//
   1197          		AMP_SetGain(gain);
   1198          		//
   1199          	}else
   1200          	if (max < SYGNAL_MIN_VALUE) {
   1201          		// Signal is Low
   1202          		CalibrFault.fCalibr_Low = 1;
   1203          	}else
   1204          	if (min > SYGNAL_MAX_VALUE) {
   1205          		// Signal is Hi
   1206          		CalibrFault.fCalibr_Hi = 1;
   1207          	}
   1208          	//
   1209          //DL3   
   1210          		//FIRE_CLR();				// Disable Fire current consumption
   1211                          NFAULT_SET();
   1212          //DL3 
   1213          	StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1214          }
   1215          	
   1216          
   1217          //========================================================
   1218          //                 ---  M A I N  ----
   1219          //========================================================
   1220          //--------------------------------------------------------------------------------
   1221          // Function		: void main(void)
   1222          // Parameters	: None
   1223          // Return		: None
   1224          // Description	: Main function. Contains main loop.
   1225          //--------------------------------------------------------------------------------
   1226          void main(void) {
   1227          	u8	byte, sh, len, irpulses = 3, fADCStarted = 0;
   1228          	int i;
   1229          	u8  loc_buf[2];
   1230          	u8  n_counter = 0;
   1231          	u8  quality;
   1232          	u16	summa = 0;
   1233          	u8	fire_level_counter = 0;
   1234          	u8	QualityFaultCounter = 0;
   1235          	u8	led_clk;
   1236          	u16	led_timer = 0;
   1237          	u8	timerA1_blank = 0;
   1238          	
   1239          	// Initialization variables and GPIO
   1240          	WDTCTL = WDTPW + WDTHOLD;				// отключаем сторожевой таймер
   1241          	// GIPIO Init
   1242          	GPIO_Init();
   1243          		
   1244          	// Init internal RC osc.
   1245          	BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1246          	DCOCTL =  CALDCO_1MHZ;
   1247          	
   1248          	DelayMs(100);
   1249          	
   1250          	// Initialization code for VLO
   1251          	__set_R4_register(0);
   1252          	//
   1253          	BCSCTL3 |= LFXT1S_2;                    // Select VLO as low freq clock
   1254          	// End initialization code
   1255          	
   1256          	WDTCTL = WDT_ADLY_16;                   // Interval timer	/* for 50 ms */
   1257          	//WDTCTL = WDT_ADLY_1_9;                   // Interval timer	/* for 5.9 ms */
   1258          	IE1 |= WDTIE;                           // Enable WDT interrupt
   1259          	//
   1260          	if (IFG1 & WDTIFG) {
   1261          		// Reset WDT
   1262          		#if (SYS_FAULT_ENABLE == 1)
   1263          		DeviceFault.fFaultSWReset = 1;
   1264          		#endif
   1265          	}
   1266          	IFG1 = 0;
   1267          	//	
   1268          	DeviceMode = MODE_NORM;
   1269          	
   1270          	//!!!!
   1271          	CH_IN_DIR |= CH_IN_BIT;
   1272                  
   1273          //DL3   
   1274                  NFAULT_SET();
   1275          //        fPWMEnabled = 0;
   1276          //DL3   	
   1277          	DelayMs(4000);
   1278                  
   1279          	Led_Flash(1);
   1280          	DelayMs(300);
   1281          	Led_Flash(1);
   1282          	
   1283          //	BREAK_DISABLE();					// Enable BI
   1284          	DelayMs(1000);
   1285          	
   1286          	_BIS_SR(GIE);    					// Interrupt enable
   1287          	DeviceStart();
   1288          
   1289          
   1290          
   1291          	AMP_SetGain(CONFIG->Gain);
   1292          	ADC_SetParam();
   1293          	cfg_reg = CONFIG->config_reg;
   1294          	
   1295          	Timer_A1_Init();
   1296          	
   1297          //	DelayMs(2000);
   1298          	
   1299          	start_timer = 400;		// 4 sec
   1300          // *****************************************************************
   1301          // ******************   M A I N   L O O P  *************************
   1302          // *****************************************************************
   1303          	while(1) {
   1304          		//-------------------------------------------------------------------------------
   1305          		//
   1306          		// ******** Обработчики событий ********
   1307          		//
   1308          		//-------------------------------------------------------------------------------
   1309          		
   1310          //-------------------------------------------------------------------------------
   1311          // TimerA0 Event		
   1312          //-------------------------------------------------------------------------------
   1313                    
   1314                        if (fTimerA_On) {				// Закончен период ожидания измерительных импульсов
   1315          		fTimerA_On = 0;
   1316                            
   1317                            BCSCTL1 = CALBC1_16MHZ; 	// Используем частоту 16 MГц
   1318                            DCOCTL =  CALDCO_16MHZ;
   1319                                    //
   1320                            TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1321                                    //
   1322                            Timer_A0_Off();				
   1323                                    
   1324                            ADC_MeasureStart();
   1325                                    
   1326                            fADCStarted =1;
   1327                                    
   1328          
   1329                            timerA1_blank = 0;
   1330            //Added for DL3
   1331                            if(fADCStarted == 1){
   1332                              fADCStarted = 0;
   1333                              while(irpulses){
   1334                                IRED_SET();
   1335          //                      DelayUs(670);
   1336                                DelayUs(1000);
   1337                                IRED_CLR();
   1338          //                      DelayUs(1330);
   1339                                DelayUs(1000);
   1340                                irpulses--;
   1341                              }
   1342                              irpulses = 3;
   1343                            }
   1344          //end Added for DL3
   1345                        }
   1346          
   1347          //-------------------------------------------------------------------------------
   1348          // fTimer50msOn Event				
   1349          //-------------------------------------------------------------------------------
   1350          		if (fTimer50msOn) {		// Получен следующий 50мс интервал
   1351          			fTimer50msOn = 0;
   1352          			//
   1353          			Timer50msCounter = 0;
   1354          		}
   1355          		
   1356          //-------------------------------------------------------------------------------
   1357          // TimerA1 Event (SysTick) 10 ms
   1358          //-------------------------------------------------------------------------------
   1359          		if (fTimerA1_On) {				// Получен следующий интервал timer
   1360          			fTimerA1_On = 0;
   1361          			
   1362          			if (start_timer) {
   1363                                    start_timer--;
   1364                                    if (start_timer == 0) {
   1365                                      CalibrFault.byte = CONFIG->calibr_fault;
   1366                                      flash_period_timer = 500;	// Need flash after 5 sec
   1367                                      strob_pulse_timer = 0;
   1368                                    }
   1369          			}
   1370          			
   1371          			if (timerKeyDown) {
   1372          				timerKeyDown++;
   1373          				if (timerKeyDown > 200 ) {			// > 2 sec - Start Calibration
   1374          					// CALIBRATION Start
   1375          					//
   1376          //debug DL3
   1377                                                JP1_Define();			// Define JP1 on BVS state
   1378          					if (jp1_state == 0) {
   1379          						// JP1 is Open 
   1380          						cfg_reg.fDrift = 1;
   1381          					}else{
   1382          						cfg_reg.fDrift = 0;
   1383          					}
   1384                                                  
   1385          					//
   1386          					// Calibration mode init 
   1387          					DeviceMode = MODE_CALIBR;
   1388          					fPWMEnabled = 1;
   1389          
   1390          					// Calibration from most amp to small
   1391          //DL3					FIRE_SET();				// Set Fire output key
   1392                                                  NFAULT_SET();
   1393          //DL3   	
   1394          
   1395          					DeviceFault.fStrobNone = 0;
   1396          					strob_pulse_timer = 0;
   1397          
   1398          					calibr_stage = 0;
   1399          					n_counter = 0;
   1400          					summa = 0;
   1401          					//
   1402          					amp_no = calibr_sequence[calibr_stage][0];
   1403          					gain = calibr_sequence[calibr_stage][1];
   1404          					reference = calibr_sequence[calibr_stage][2];
   1405          					//
   1406          					AMP_SetGain(gain);
   1407          					
   1408          					QualityFaultCounter = 0;
   1409          					DeviceFault.byte = 0;
   1410          					CalibrFault.byte = 0;
   1411          					fault_timer = 0;
   1412          					fault_phase = 0;
   1413          					
   1414          					RED_CLR();
   1415          					YEL_CLR();
   1416          					
   1417          					timerKeyDown = 0;
   1418          					
   1419          					flash_period_timer = 120;	// Flash after 1.2 sec
   1420          					light_timer = 7;			// Value - the power of LED light
   1421          				}
   1422          			}
   1423          			
   1424          			if (zero_timer) {
   1425          				zero_timer++;
   1426          			}
   1427          				
   1428          			if (fault_chain_timer)  {
   1429          				fault_chain_timer--;
   1430          				if (DeviceMode != MODE_FIRE) {
   1431          					if (fault_chain_timer == 0) {
   1432          						if (fault_sequence[fault_chain_ind] == 0) {
   1433          							fault_chain_ind = 0;
   1434          							DeviceMode = MODE_NORM;
   1435          //added for DL3
   1436          //                                                        fPWMEnabled = 0;
   1437          //end added for DL3
   1438          						}else{
   1439          							DeviceMode = fault_sequence[fault_chain_ind++];
   1440          							fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1441          							//
   1442          							switch (DeviceMode) {
   1443          								case MODE_FIRE:
   1444          									FIRE_SET();
   1445          									//
   1446          									RED_SET();
   1447          									YEL_CLR();
   1448          									fault_chain_timer = 0;
   1449          
   1450          									zero_timer = 0;
   1451          									DeviceFault.fSignal_Low = 0;
   1452          									break;
   1453          								case MODE_FAULT:
   1454          //									BREAK_ENABLE();			// Disable of transmitter
   1455                                                                                  NFAULT_CLR();
   1456                                                                                  break;
   1457          								case MODE_NORM:
   1458                                                                                  zero_timer = 0;
   1459          									DeviceFault.fSignal_Low = 0;
   1460          //DL3									BREAK_DISABLE();		// Enable of transmitter
   1461                                                                                  NFAULT_SET();
   1462          //end DL3
   1463          							}
   1464          						}
   1465          					}
   1466          				}
   1467          			}
   1468          			
   1469          			if (timerMain) {
   1470          				timerMain--;
   1471          				if (timerMain == 0) {
   1472          					if (DeviceMode == MODE_TEST) {
   1473          						DeviceMode = MODE_NORM;
   1474          						RED_CLR();
   1475          						YEL_CLR();
   1476          //DL3   
   1477                                                          //FIRE_CLR();
   1478                                                          NFAULT_SET();
   1479          //                                                fPWMEnabled = 0;
   1480          //DL3 
   1481          					}
   1482          				}
   1483          			}
   1484          			//
   1485          			// Setting signals in Fault Mode (LEDs and other pins)
   1486          			FaultSignalManager();
   1487          			//
   1488          			
   1489          			if (timerA1_blank) {
   1490          				timerA1_blank--;
   1491          			}else{
   1492          				// ---- LED Indication ----
   1493          				//
   1494          				if (light_timer) {
   1495          					light_timer--;
   1496          					//
   1497          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1498          						RED_SET();
   1499          						YEL_CLR();
   1500          					}else
   1501          					//
   1502          					if (DeviceMode == MODE_CALIBR) {
   1503          						RED_SET();
   1504          						YEL_SET();
   1505          					}
   1506          				}else{
   1507          					//
   1508          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_CALIBR) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1509                                                          RED_CLR();
   1510          						YEL_CLR();
   1511          					}
   1512          				}
   1513          				//	
   1514          				if ((DeviceMode == MODE_FAULT) || (DeviceMode == MODE_TEST)) {
   1515          					//
   1516          					// LED management
   1517          					//
   1518          					if (light_sync >= 3) {
   1519          						light_sync = 0;
   1520          						led_sh = 0x80000000;
   1521          						//
   1522          						led_timer = 300;	// 3 sec period
   1523          					}
   1524          					
   1525          					if (led_timer) {
   1526          						led_timer--;
   1527          					}else{
   1528          						led_timer = 300;	// 3 sec period
   1529          						led_sh = 0x80000000;
   1530          						//
   1531          						light_sync = 0;
   1532          					}
   1533          					//
   1534          					if (++led_clk >= 4) {		// T = 30 ms
   1535          						led_clk = 0;
   1536          						//
   1537          						if (led_r & led_sh) {
   1538          							RED_SET();
   1539          //							CH_IN_SET();
   1540          						}else{
   1541          							RED_CLR();
   1542          //							CH_IN_CLR();
   1543          						}
   1544          						//
   1545          						if (led_y & led_sh) {
   1546          							YEL_SET(); 
   1547          						}else{
   1548          							YEL_CLR();
   1549          						}
   1550          						//
   1551          						if (DeviceMode == MODE_TEST) {
   1552          							YEL_SET(); 
   1553          						}
   1554          						//
   1555          						led_sh >>= 1;
   1556          					}
   1557          				}
   1558          			} // End indication
   1559          
   1560          // Added for DL3
   1561                                  if(DeviceMode == MODE_FIRE){
   1562                                    fStartPulse = 0;
   1563                                  }
   1564                                  else
   1565                                    if (strob_pulse_timer == 0) {
   1566                                      fStartPulse = 1;                        
   1567                                      strob_pulse_timer = 120;
   1568                                    }
   1569                                    else{
   1570                                      strob_pulse_timer--;
   1571                                    }
   1572          
   1573          //DL3 PWM 
   1574                                    if(fPWMEnabled){
   1575                                            Timer_A0_StartPWM(PWM_period);
   1576                                          }
   1577          //end DL3 PWM      
   1578          //end  Added for DL3
   1579          
   1580          			//
   1581          			if (flash_period_timer) {
   1582          				flash_period_timer--;
   1583          				if (flash_period_timer == 0) {
   1584          					flash_period_timer = 120;	// Flash after 1.2 sec
   1585          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)){
   1586          						light_timer = 1;				// Value - the light power
   1587          					}else
   1588          					if (DeviceMode == MODE_CALIBR) {
   1589          						light_timer = 7;				// Value - the light power
   1590          					}
   1591          				}
   1592          			}
   1593                                  
   1594          		} // if (fTimerA1_On 10 ms)
   1595          		
   1596          //-------------------------------------------------------------------------------
   1597          // End of samples of ADC Event
   1598          		if (fEndOfSamples) {	// End of samples of ADC Event
   1599          			fEndOfSamples = 0;
   1600          		
   1601          			//VREF_Off();						// Vref Disable
   1602          			ADC10CTL0 &= ~ENC;
   1603          			while (ADC10CTL1 & BUSY);           // Wait if ADC10 core is active 
   1604          			ADC10CTL0 &= ~REFON;
   1605          			
   1606          			AMP_PWR_OFF();						// AMP Power Supply Disable
   1607          			//AMP_Off_Timer = CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;	//CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;
   1608          			//
   1609          
   1610          			BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 8 MГц
   1611          			DCOCTL =  CALDCO_8MHZ;
   1612          			//
   1613          			TA1CCR0  = 0xFFFF - 1;   			// ~ Compensation of frequence increase
   1614          			//
   1615          			DelayUs(1);
   1616          			//
   1617          			if (fSendingGraph) {
   1618          				loc_buf[0] = Q_SEND_GRAPH1;
   1619          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1620          				SoftUART_TxString(loc_buf, 2);
   1621          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1622          
   1623          
   1624          			}
   1625          			//
   1626          			if (start_timer || CalibrFault.byte || DeviceFault.fFaultDrift) {
   1627          				goto label_light;
   1628          			}
   1629          
   1630                                 if((DeviceMode == MODE_TEST) ||(DeviceMode == MODE_FAULT)){
   1631                                     fPWMEnabled = 1;  
   1632                                     Timer_A0_StartPWM(PWM_period);
   1633                                  }
   1634                                  else{
   1635                                     fPWMEnabled = 0;  
   1636                                  }
   1637                                  
   1638          			quality = SignalAnalysis();
   1639          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1640          			DCOCTL =  CALDCO_1MHZ;
   1641          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1642          			DelayUs(1);
   1643                                  
   1644          			//
   1645          			if (DeviceMode == MODE_CALIBR) {
   1646          				//
   1647          				// -------- CALIBRATION ---------
   1648          				//
   1649          				n_counter++;
   1650          				summa += delta;
   1651          				
   1652          				if (n_counter >= 2) {
   1653          					delta = summa / n_counter;
   1654          		
   1655          					n_counter = 0;
   1656          					summa = 0;
   1657          					//
   1658          					s_array[calibr_stage] = delta;
   1659          					q_array[calibr_stage] = quality;
   1660          					//
   1661          					if (++calibr_stage >= CALIBR_STAGES) {
   1662          						// End of calibration
   1663          						//
   1664          						CalibrationResultAnalise();
   1665          						if (CalibrFault.byte) {
   1666          							DeviceMode = MODE_FAULT;
   1667          						}
   1668          						//
   1669          						goto label_light;
   1670          					}
   1671          					//
   1672          					//	Set new	 Amp_No	Gain  Reference
   1673          					amp_no = calibr_sequence[calibr_stage][0];
   1674          					gain = calibr_sequence[calibr_stage][1];
   1675          					reference = calibr_sequence[calibr_stage][2];
   1676          					//
   1677          					AMP_SetGain(gain);
   1678          					//
   1679          				}
   1680          			}else
   1681          			
   1682          			// -------- NORM behavior -------------
   1683          			//
   1684          			if (quality == 2) {	
   1685          				// Very high signal
   1686          				if (++QualityFaultCounter > 10) {
   1687          					CalibrFault.fCalibr_Hi = 1;
   1688          					QualityFaultCounter = 0;
   1689          				}
   1690          				//
   1691          				goto label_light;
   1692          			}else{
   1693          				QualityFaultCounter = 0;
   1694          			}
   1695          			
   1696          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && fault_chain_timer) {
   1697          				// Обрабатывается полное перекрытие
   1698          				if (delta > getZeroLevel()) {
   1699          					fault_chain_timer = 0;
   1700          					fault_chain_ind = 0;
   1701          					DeviceFault.fSignal_Low = 0;
   1702          				}
   1703          			}
   1704          			
   1705          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && (fault_chain_timer == 0)) {
   1706          				if ((delta >= CONFIG->limit_fire) && (delta <= SYGNAL_MAX_VALUE)) {
   1707          					// Reset all counters
   1708          					fire_level_counter = 0;
   1709          					hi_signal_counter = 0;
   1710          					zero_timer = 0;
   1711          				}
   1712          								
   1713          				if (delta <= getZeroLevel()) {
   1714          					if (zero_timer == 0) {	
   1715          						zero_timer = 1;
   1716          					}else
   1717          					if (zero_timer > 1000) {	// 10 sec
   1718          						// Полное перекрытие 
   1719          						fault_chain_ind = 0;
   1720          						DeviceMode = fault_sequence[fault_chain_ind++];
   1721          						fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1722          						DeviceFault.fSignal_Low = 1;
   1723          						zero_timer = 0;
   1724          						//
   1725          //DL3						BREAK_ENABLE();			// Disable of transmitter
   1726                                                          NFAULT_CLR();
   1727          
   1728          						//
   1729          					}
   1730          				}else{
   1731          					zero_timer = 0;
   1732          					//
   1733          					if (delta < CONFIG->limit_prefire) {
   1734          						DeviceMode = MODE_PREPREFIRE;
   1735          					}
   1736          					
   1737          					if (DeviceMode == MODE_PREPREFIRE) {
   1738          						if (delta > CONFIG->limit_prefire) {
   1739          							DeviceMode = MODE_NORM;
   1740          						}
   1741          					}
   1742          					
   1743          					if (delta < CONFIG->limit_fire) {
   1744          						fire_level_counter = 5;
   1745          						DeviceMode = MODE_PREFIRE;
   1746          					}
   1747          					
   1748          					// Hi signal management
   1749          					if (delta > SYGNAL_MAX_VALUE) {
   1750          						// Very high signal
   1751          						hi_signal_counter++;
   1752          						if (hi_signal_counter >= 10) {
   1753          							//DeviceMode = MODE_FAULT;
   1754          							CalibrFault.fCalibr_Hi = 1;
   1755          							hi_signal_counter = 0;
   1756          						}
   1757          					}
   1758          				}
   1759          			}else
   1760          			if (DeviceMode == MODE_PREFIRE) {
   1761          				//
   1762          				// Защита от плавного изменения уровня сигнала
   1763          				if ((delta == 0) && (delta_last > 0)) {
   1764          					fire_level_counter = 10;
   1765          				}
   1766          				//	
   1767          				if ((delta <= getZeroLevel()) && (fire_level_counter == 5)) {
   1768          					if (zero_timer == 0) {	
   1769          						zero_timer = 1;
   1770          						DeviceMode = MODE_NORM;
   1771          					}
   1772          				}else
   1773          				if (delta < CONFIG->limit_fire) {
   1774          					if (--fire_level_counter == 0) {
   1775          						DeviceMode = MODE_FIRE;
   1776          						FIRE_SET();
   1777          						RED_SET();
   1778          						YEL_CLR();
   1779          						DeviceFault.byte = 0;
   1780          					}
   1781          				}else{
   1782          					DeviceMode = MODE_NORM;
   1783          				}
   1784          				//
   1785          				delta_last = delta;
   1786          			}
   1787          			//
   1788          			if (CONFIG->config_reg.fDrift) {
   1789          				// if JP1 state is open
   1790          				if ((DeviceMode == MODE_NORM) && delta) {
   1791          					// Long Term Drift Adjustment
   1792          					DriftSumma += delta;
   1793          					DriftCounter++;
   1794          					if (DriftCounter >= DRIFT_SAMPLES_MAX) {
   1795          						DriftLevel = DriftSumma / DriftCounter;
   1796          						//
   1797          						if ((u16)DriftLevel < CONFIG->limit_drift) {
   1798          							//
   1799          							DeviceFault.fFaultDrift = 1;
   1800          							SetFaultMode();
   1801          							//
   1802          							SetLevels(CONFIG->limit_drift);
   1803          						}else{
   1804          							SetLevels((u16)DriftLevel);
   1805          						}
   1806          						//	
   1807          						ClearDriftVar();
   1808          						//
   1809          					}
   1810          				}
   1811          			}
   1812          			//			
   1813          			//
   1814          label_light:			
   1815          			//
   1816          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1817          			DCOCTL =  CALDCO_1MHZ;
   1818          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1819          			//
   1820          			DelayUs(1);
   1821          			//
   1822          
   1823                                  if (fSendingGraph) {
   1824          //DL3
   1825          
   1826          
   1827          				BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 8 MГц
   1828          				DCOCTL =  CALDCO_8MHZ;
   1829          				TA1CCR0  = 0xFFFF - 1;   				// ~ Compensation of frequence increase
   1830          				//
   1831          				//
   1832          				for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
   1833          					signal_array[i] += 350;
   1834          				}
   1835          				
   1836          				loc_buf[0] = Q_SEND_GRAPH2;
   1837          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1838          				SoftUART_TxString(loc_buf, 2);
   1839          				//
   1840          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1841          				
   1842          				SoftUART_TxString((u8*)&delta, 2);
   1843          				
   1844          				fSendingGraph = 0;
   1845          				//
   1846          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1847          				DCOCTL =  CALDCO_1MHZ;
   1848          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1849          				//
   1850          
   1851          //end DL3
   1852          			}
   1853          			//
   1854          			//
   1855          			// Indication
   1856          			//
   1857          			if (DeviceMode == MODE_NORM) {
   1858          				light_timer = 1;				// Value - the light power
   1859          				flash_period_timer = 120;		// Flash after 1.2 sec
   1860          //				flash_period_timer = 200;		// Flash after 2 sec
   1861          			}
   1862          			//
   1863          			if ((DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1864          				light_timer = 4;				// Value - the light power
   1865          				flash_period_timer = 120;		// Flash after 1.2 sec
   1866          //				flash_period_timer = 60;		// Flash after 1.2 sec
   1867          			}
   1868          			//
   1869          			if (DeviceMode == MODE_CALIBR) {
   1870          				light_timer = 7;				// Value - the light power
   1871          				flash_period_timer = 120;		// Flash after 1.2 sec
   1872          			}
   1873          			//
   1874          			if (DeviceMode == MODE_TEST) {
   1875          				// Indication sygnal level
   1876          				LedTestValueManager();			
   1877          				//
   1878          			}
   1879          			//
   1880          			light_sync++;
   1881          			led_timer = 400;	//4 sec
   1882          //			STROB_IE_Enable();
   1883          		}
   1884          		
   1885          //-------------------------------------------------------------------------------
   1886          // Strobe StartPulse Event		
   1887          		if (fStartPulse) {			// Start pulse was received
   1888          			fStartPulse = 0;
   1889          	
   1890          
   1891          			//
   1892          			AMP_PWR_ON();						// AMP Power Supply Enable
   1893          			// Vref Enable
   1894          			if (DeviceMode == MODE_CALIBR) {
   1895          				ADC_MeasureInit(amp_no, reference);
   1896          			}else{
   1897          				ADC_MeasureInit(CONFIG->AMP_No, reference);
   1898          			}
   1899          			
   1900          			_BIC_SR(GIE);    			// Запрещаем прерывания
   1901          
   1902            //DL3                        Timer_A0_SetDelay(2250);
   1903                                  Timer_A0_StopPWM();
   1904                                  Timer_A0_SetDelay(1500);
   1905          
   1906          //                        
   1907          			_BIS_SR(GIE);    			// Разрешаем прерывания
   1908          			//
   1909          			BCSCTL1 = CALBC1_8MHZ; 		// Используем частоту 8 MГц
   1910          			DCOCTL =  CALDCO_8MHZ;
   1911          			//
   1912          			TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1913          			//
   1914          			// For define the presence of strob pulses
   1915          //DL3			strob_pulse_timer = 0;
   1916                                  
   1917          			DeviceFault.fStrobNone = 0;
   1918          			//
   1919          			fault_phase = 0;
   1920          			fault_timer = 0;
   1921          		}
   1922          		
   1923          
   1924          //-------------------------------------------------------------------------------
   1925          // KEY DOWN event		
   1926          		if (fButtonDownOn) {									// Нажата кнопка
   1927          			fButtonDownOn = 0;
   1928          			//...
   1929          			timerKeyDown = 1;
   1930          			//
   1931          		} // if (fButtonDownOn)
   1932          		
   1933          //-------------------------------------------------------------------------------
   1934          // KEY UP event
   1935          		if (fButtonUpOn) {			// Отжата кнопка
   1936          			fButtonUpOn = 0;
   1937          
   1938          			if ((timerKeyDown > 4) && (timerKeyDown < 150))  {	// < 1.5 sec
   1939          				// The short pressure on the button
   1940          				if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1941          					DeviceMode = MODE_TEST;
   1942          					DeviceFault.byte = 0;	// Reset all faults
   1943          
   1944          //DL3                                   FIRE_SET();				// Set fire mode current consumption
   1945                                                  NFAULT_SET();
   1946          //DL3 
   1947          					RED_CLR();
   1948          					YEL_SET();
   1949          					timerMain = 12000;		// 120 sec
   1950          					led_sh = 0;
   1951          					led_timer = 0;			// Устраняем задержку оптической индикации
   1952          					led_clk = 0xFF;
   1953                                                  
   1954                                                  fPWMEnabled = 1;
   1955          				}else
   1956          				//	
   1957          				if (DeviceMode == MODE_TEST) {
   1958          					DeviceMode = MODE_NORM;
   1959                                                  
   1960          //                                        fPWMEnabled = 0;
   1961          					
   1962                                                  DeviceFault.byte = 0;	// Reset all faults
   1963          					//led_timer = 0;
   1964          					RED_CLR();
   1965          					YEL_CLR();
   1966          //
   1967          //					FIRE_CLR();
   1968                                                  NFAULT_SET();
   1969          //DL3 
   1970          				}else
   1971          				//
   1972          				if (DeviceMode == MODE_FIRE) {
   1973          					DeviceMode = MODE_NORM;
   1974          					DeviceFault.byte = 0;	// Reset all faults
   1975          					RED_CLR();
   1976          					YEL_CLR();
   1977          
   1978          //DL3 
   1979          					FIRE_CLR();				// Disable Fire Output
   1980                                                  NFAULT_SET();
   1981          //DL3 
   1982          					led_r = 0;
   1983          					led_y = 0;
   1984          				}
   1985          			}
   1986          			//
   1987          			timerKeyDown = 0;
   1988          		} // if (fButtonUpOn) {
   1989          
   1990          		
   1991          //-------------------------------------------------------------------------------
   1992          // Soft UART Rx Hundler
   1993          		if (fRxLineDownOn) {
   1994          
   1995          			uart_rx_ind = 0;
   1996          // DL3
   1997          			//
   1998          label_rx_continue:
   1999          			fRxLineDownOn = 0;
   2000          			//
   2001          			DelayUs_8MHz(25);		// Delay to center of pulse
   2002          			//
   2003          			CH_IN_SET();
   2004          			CH_IN_CLR();
   2005          			//
   2006          			if ((INTER_BIT & INTER_IN) == 0) {
   2007          				SoftUART_SetReceiveByte();
   2008          				
   2009          			}else{
   2010          				//
   2011          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   2012          				DCOCTL =  CALDCO_1MHZ;
   2013          				//
   2014          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	                // Period T(us) * F(MHz)
   2015          				//
   2016          				continue;		                                // False pulse
   2017          			}
   2018          			sh = 0x01;
   2019          			byte = 0;
   2020          			while (sh) {
   2021          				if (fTimerA_On) {
   2022          					fTimerA_On = 0;
   2023          					//
   2024          					//CH_IN_SET();
   2025          					//CH_IN_CLR();
   2026          					//
   2027          					if (INTER_BIT & INTER_IN) {
   2028          						byte |= sh;
   2029          					}
   2030          					sh <<= 1;
   2031          				}
   2032          			}
   2033          			// Receive byte
   2034          			SoftUART_ResetReceiveByte();
   2035          			//
   2036          			if (uart_rx_ind == 0) {
   2037          				// Begin of packet
   2038          				len = packet_len_table[byte];
   2039          				if (len > UART_BUF_LEN) {
   2040          					len = UART_BUF_LEN;
   2041          				}
   2042          			}
   2043          				
   2044          			*(uart_rx_buf+uart_rx_ind++) = byte;
   2045          			if (uart_rx_ind >= len) {
   2046          				// Parse of packet
   2047          				//...
   2048          				SoftUART_RxParse();
   2049          				INTER_IFG &= ~INTER_BIT;    				// Обнуляем флаг прерывания
   2050          				fRxLineDownOn = 0;
   2051          			}else{
   2052          				//			
   2053          				uart_timer = 4;								// 200 ms timeout to next byte
   2054          				while (1) {
   2055          					//__bis_SR_register(LPM3_bits + GIE);     // Enter LPM3
   2056          					//
   2057          					while ((fRxLineDownOn || fTimer50msOn) == 0) {}
   2058          					//
   2059          					if (fRxLineDownOn) {
   2060          						goto label_rx_continue;
   2061          					}
   2062          					if (fTimer50msOn) {						// Получен следующий 50мс интервал
   2063          						fTimer50msOn = 0;
   2064          						//
   2065          						if (uart_timer) {
   2066          							uart_timer--;
   2067          						}else{
   2068          							// End of Rx timeout
   2069          							//...
   2070          							INTER_IFG &= ~INTER_BIT;    	// Обнуляем флаг прерывания
   2071          							fRxLineDownOn = 0;
   2072          							break;
   2073          						}
   2074          					}
   2075          				}
   2076          			}
   2077          			//
   2078          			//
   2079          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   2080          			DCOCTL =  CALDCO_1MHZ;
   2081          			//
   2082          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   2083          			//
   2084          
   2085                             //
   2086          		} // Soft UART Rx Hundler
   2087          	} // while(1)
   2088          }
   2089          
   2090          
   2091          
   2092          
   2093          //--------------------------------------------------------------------------------
   2094          // Function		: __interrupt void watchdog_timer (void)
   2095          // Parameters	: None
   2096          // Return		: None
   2097          // Description	: WDT Interrupt routine
   2098          //--------------------------------------------------------------------------------
   2099          #pragma vector=WDT_VECTOR
   2100          __interrupt void watchdog_timer (void) {
   2101          	
   2102          	if (fTimer50msOn) {
   2103          		if (++Timer50msCounter == 0) {		// > ~ 12sec
   2104          //			WDTCTL = WDTCTL;				// Hardware RESET
   2105          		}
   2106          	}
   2107          	fTimer50msOn = 1;
   2108          	
   2109          //	__bic_SR_register_on_exit(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
   2110                  LPM3_EXIT;
   2111          }
   2112          
   2113          
   2114          
   2115          //--------------------------------------------------------------------------------
   2116          // Function		: __interrupt void CCR0_ISR(void)
   2117          // Parameters	: None
   2118          // Return		: None
   2119          // Description	: TIMER0 Interrupt routine
   2120          //--------------------------------------------------------------------------------
   2121          #pragma vector = TIMER0_A0_VECTOR
   2122          __interrupt void CCR0_ISR(void) {
   2123                    fTimerA_On = 1;
   2124          	
   2125          } // CCR0_ISR
   2126          
   2127          #pragma vector = TIMER0_A1_VECTOR
   2128          __interrupt void CCR_ISR(void) {
   2129                  TEST_OUT_SET();
   2130          } // CCR0_ISR
   2131          
   2132          
   2133          //--------------------------------------------------------------------------------
   2134          // Function		: __interrupt void Timer_A1_ISR (void)
   2135          // Parameters	: None
   2136          // Return		: None
   2137          // Description	: TIMER1 Interrupt routine
   2138          //--------------------------------------------------------------------------------
   2139          #pragma vector=TIMER1_A0_VECTOR
   2140          __interrupt void Timer_A1_ISR (void)  {
   2141          	
   2142          	fTimerA1_On = 1;
   2143          
   2144          	//__bic_SR_register_on_exit(LPM0_bits);                   // Clear LPM3 bits from 0(SR)
   2145          } 
   2146          
   2147          
   2148          
   2149          //--------------------------------------------------------------------------------
   2150          // Function		: void Led_Flash(u16 duration)
   2151          // Parameters	: duration - duration Red LED flash in ms
   2152          // Return		: None
   2153          // Description	: Flashing red LED
   2154          //--------------------------------------------------------------------------------
   2155          void Led_Flash(u16 duration) {
   2156                  IRED_SET();
   2157                  DelayUs(100);
   2158          	IRED_CLR();
   2159                  
   2160                  RED_SET();
   2161                  YEL_SET();
   2162          	DelayMs(duration);
   2163                  RED_CLR();
   2164                  YEL_CLR();
   2165          }
   2166          
   2167          //--------------------------------------------------------------------------------
   2168          // Function		: void VREF_On(void)
   2169          // Parameters	: None 
   2170          // Return		: None
   2171          // Description	: Enable VREF
   2172          //--------------------------------------------------------------------------------
   2173          void VREF_On(void) {
   2174          
   2175          	ADC10CTL0 = REFOUT + REFON + SREF_1 + MSC + ADC10ON;
   2176          	ADC10AE0 |= 0x10;                         // P1.4 ADC option select (VRef Out)
   2177          
   2178          }
   2179          
   2180          
   2181          
   2182          //--------------------------------------------------------------------------------
   2183          // Function		: void VREF_Off(void)
   2184          // Parameters	: None
   2185          // Return		: None
   2186          // Description	: Disable VREF
   2187          //--------------------------------------------------------------------------------
   2188          void VREF_Off(void) {
   2189          
   2190          	ADC10CTL0 = 0;							// Disable ADC & +VREF
   2191          	ADC10CTL0 = 0;							//
   2192          }
   2193          
   2194          
   2195          
   2196          //--------------------------------------------------------------------------------
   2197          // Function		: void ADC10_ISR(void)
   2198          // Parameters	: None
   2199          // Return		: None
   2200          // Description	: ADC10 interrupt service routine
   2201          //--------------------------------------------------------------------------------
   2202          #pragma vector=ADC10_VECTOR
   2203          __interrupt void ADC10_ISR(void) {
   2204          
   2205          	//ADC10AE0 &= ~0x0F;                      // Save only VRef Out
   2206          	
   2207          	adc_process = 0;
   2208          	
   2209          	fEndOfSamples = 1;
   2210                  
   2211          	//__bic_SR_register_on_exit(CPUOFF);      // Clear CPUOFF bit from 0(SR)
   2212          	
   2213          }
   2214          
   2215          
   2216          
   2217          //--------------------------------------------------------------------------------
   2218          // Function		: u16 AverageData(u16 * data_ptr, u8 len)
   2219          // Parameters	: data_ptr - data array pointer, len - length of data array
   2220          // Return		: Average value of data
   2221          // Description	: Fuction calculate the average value of data array
   2222          //--------------------------------------------------------------------------------
   2223          u16 AverageData(u16 * data_ptr, u8 len) {
   2224          	u16 summa = 0;
   2225          	u8  i = len;
   2226          	while (i--) {
   2227          		summa += *data_ptr++;
   2228          	}
   2229          	//
   2230          	return (summa/len);
   2231          }
   2232          
   2233          
   2234          //--------------------------------------------------------------------------------
   2235          // Function		: void DeviceDiagnostics(void)
   2236          // Parameters	: None
   2237          // Return		: None
   2238          // Description	: Procedure of the diagnostics device
   2239          //--------------------------------------------------------------------------------
   2240          void DeviceDiagnostics(void) {
   2241          	//
   2242          	DelayMs(100);
   2243          	//
   2244          	//
   2245          		
   2246          #if (CRC_ENABLE == 1)
   2247          	// Check CS of Memory
   2248          	DeviceFault.fFaultCRC = 0;
   2249          	if (GetPropertiesCS() != CONFIG->CS) {
   2250          		DeviceFault.fFaultCRC = 1;
   2251          	}
   2252          #endif
   2253          }
   2254          
   2255          //--------------------------------------------------------------------------------
   2256          // Function		: u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count)
   2257          // Parameters	: refout = 0 or REFOUT, vref = REF1_5V , count - кол-во измерений 
   2258          // Return		: None
   2259          // Description	: Measurement of the current temperature of MCU
   2260          //--------------------------------------------------------------------------------
   2261          #pragma optimize=none
   2262          u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count) {
   2263          	u16 res;
   2264          
   2265          	while(adc_process) {}
   2266          	
   2267          	BUT_IE &= ~BUT_BIT;
   2268          	BUT_REN &= ~BUT_BIT; 		// PULL disable
   2269          	
   2270          	ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC  + ADC10ON + ADC10IE;	// Sample&hold = 8 x ADC10CLKs
   2271          	
   2272          	DelayUs(50);	
   2273          	//
   2274          	ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ch;	// ADC_BUT;     // 
   2275          	//
   2276          	DelayUs(200);							// Delay to allow Ref to settle
   2277          
   2278          	ADC10DTC1 = count;						// count of conversions
   2279          	ADC10AE0 = ADC_AE_BUT;                 // A3 & A7 ADC option select
   2280          	//
   2281          	ADC10SA = (u16) &buf[0];          		// Data buffer start
   2282          	
   2283          	fEndOfSamples = 0;
   2284          	ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
   2285          		
   2286          	__bis_SR_register(CPUOFF + GIE);        // LPM0, ADC10_ISR will force exit
   2287          	
   2288          	while (fEndOfSamples == 0){};
   2289          	fEndOfSamples = 0;
   2290          
   2291          	res = AverageData(buf, count);	
   2292          
   2293          	ADC10AE0 = ADC_AE;          // A3 & A7 ADC option select
   2294          	
   2295          	BUT_IFG &= ~BUT_BIT;    	// Обнуляем флаг прерывания
   2296          	BUT_IE |= BUT_BIT;
   2297          	BUT_REN |= BUT_BIT; 		// PULL enable
   2298          	
   2299          	return res;
   2300          }
   2301          
   2302          
   2303          //--------------------------------------------------------------------------------
   2304          // Function		: void u8 JP1_Define(void)
   2305          // Parameters	: None
   2306          // Return		: 0 - JP1 Open, 1 - JP1 Close
   2307          // Description	: Definition of JP1 state
   2308          //--------------------------------------------------------------------------------
   2309          void JP1_Define(void) {
   2310          	u16 buf[4];
   2311          	u16 temp;
   2312          	
   2313          	temp = ADC_Measure_Simple(ADC_BUT, buf, 4);
   2314          	
   2315          	if (temp > 600) return; 
   2316          	if (temp > 100) {
   2317          		jp1_state = 0;		// JP1 is Open 
   2318          	}else{
   2319          		jp1_state = 1;		// JP1 is Close
   2320          	}	
   2321          	//
   2322          	return;	
   2323          }
   2324          
   2325          
   2326          // End of main.c

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   ADC10_ISR
      4   ADC_MeasureInit
        4   -> DelayUs
      2   ADC_MeasureStart
     10   ADC_Measure_Simple
       10   -> AverageData
       10   -> DelayUs
       10 ?Epilogue4
      2   ADC_SetParam
      2   AMP_Gain_Init
        0   -> AMP_SetGain
      2   AbsValue
      4   AverageData
        4 ?DivMod16u
      4   CCR0_ISR
      4   CCR_ISR
     22   CalibrationResultAnalise
       22   -> AMP_SetGain
       22   -> SetLevelsFromCalibr
       22   -> SetLimitCompens
       22   -> StoragePropertyByte
       22   -> StoragePropertyWord
       14 ?Epilogue6
      2   ClearDriftVar
      2   DeviceDiagnostics
        2   -> DelayMs
        2   -> GetPropertiesCS
      2   DeviceStart
        0   -> ClearDriftVar
        2   -> VLO_TimerCalibr
      2   FaultSignalManager
     10   JP1_Define
       10   -> ADC_Measure_Simple
      2   LedTestValueManager
      4   Led_Flash
        4   -> DelayMs
        4   -> DelayUs
      2   SetFaultMode
      6   SetLevels
        6   -> ClearDriftVar
        6   -> SavePropertyCS
        6   -> StoragePropertyWord
        6 ?DivMod16s
        6 ?DivMod16u
      6   SetLevelsFromCalibr
        6   -> ClearDriftVar
        6   -> SavePropertyCS
        6   -> StoragePropertyWord
        6 ?DivMod16u
      2   SetLimitCompens
        0   -> ClearDriftVar
        2   -> SavePropertyCS
        2   -> StoragePropertyWord
     28   SignalAnalysis
       28   -> AverageData
       28   -> fir_filter
       28 ?DivMod16s
       14 ?Epilogue6
      2   TimerA1_DelayUs
      2   Timer_A0_Off
      2   Timer_A0_SetDelay
      2   Timer_A0_SetPWMPulse
      4   Timer_A0_StartPWM
        4 ?DivMod16u
      2   Timer_A0_StopPWM
      4   Timer_A1_ISR
      2   Timer_A1_Init
      2   VLO_GetPeriod
      2   VLO_TimerCalibr
        2   -> SavePropertyCS
        2   -> StoragePropertyWord
      2   VREF_Off
      2   VREF_On
      8   fir_filter
        8 ?DivMod32s
        8 ?Epilogue3
        8 ?Mul16to32s
        8 ?ShiftRight32s_9
      2   getTimerValue
      2   getZeroLevel
        0 ?DivMod16u
     12   main
       12   -> ADC_MeasureInit
       12   -> ADC_MeasureStart
       12   -> ADC_SetParam
       12   -> AMP_SetGain
       12   -> CalibrationResultAnalise
       12   -> ClearDriftVar
       12   -> DelayMs
       12   -> DelayUs
       12   -> DelayUs_8MHz
       12   -> DeviceStart
       12   -> FaultSignalManager
       12   -> GPIO_Init
       12   -> JP1_Define
       12   -> LedTestValueManager
       12   -> Led_Flash
       12   -> SetFaultMode
       12   -> SetLevels
       12   -> SignalAnalysis
       12   -> SoftUART_ResetReceiveByte
       12   -> SoftUART_RxParse
       12   -> SoftUART_SetReceiveByte
       12   -> SoftUART_TxString
       12   -> Timer_A0_Off
       12   -> Timer_A0_SetDelay
       12   -> Timer_A0_StartPWM
       12   -> Timer_A0_StopPWM
       12   -> Timer_A1_Init
       12   -> getTimerValue
       12   -> getZeroLevel
       12 ?DivMod16u
       12 ?DivMod32u
      4   watchdog_timer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for jp1_state>
       1  ADC10AE0
       2  ADC10CTL0
       2  ADC10CTL1
       1  ADC10DTC1
       2  ADC10SA
      10  ADC10_ISR
       2  ADC10_ISR::??INTVEC 10
      92  ADC_MeasureInit
      24  ADC_MeasureStart
     140  ADC_Measure_Simple
      36  ADC_SetParam
       8  AMP_Gain_Init
      14  AbsValue
      30  AverageData
       1  BCSCTL1
       1  BCSCTL3
       1  CALBC1_16MHZ
       1  CALBC1_1MHZ
       1  CALBC1_8MHZ
       1  CALDCO_16MHZ
       1  CALDCO_1MHZ
       1  CALDCO_8MHZ
       4  CCR0_ISR
       2  CCR0_ISR::??INTVEC 18
       2  CCR1_Value
       8  CCR_ISR
       2  CCR_ISR::??INTVEC 16
       1  CalibrFault
     420  CalibrationResultAnalise
      22  ClearDriftVar
       1  DCOCTL
      32  DeviceDiagnostics
       1  DeviceFault
       1  DeviceMode
      16  DeviceStart
       2  DriftCounter
       4  DriftLevel
       4  DriftSumma
      18  FIRCoef
     274  FaultSignalManager
       1  FireMeasCount
       1  IE1
       1  IFG1
      36  JP1_Define
     132  LedTestValueManager
      54  Led_Flash
       1  P1IE
       1  P1IFG
       1  P1OUT
       1  P1REN
       1  P1SEL
       1  P2DIR
       1  P2IFG
       1  P2IN
       1  P2OUT
       2  PWM_period
      24  SetFaultMode
      94  SetLevels
     162  SetLevelsFromCalibr
      24  SetLimitCompens
     560  SignalAnalysis
       2  TA0CCR0
       2  TA0CCR1
       2  TA0CCTL0
       2  TA0CCTL1
       2  TA0CTL
       2  TA0R
       2  TA1CCR0
       2  TA1CCTL0
       2  TA1CTL
       2  TA1R
       1  Timer50msCounter
      40  TimerA1_DelayUs
      30  Timer_A0_Off
      42  Timer_A0_SetDelay
      22  Timer_A0_SetPWMPulse
      94  Timer_A0_StartPWM
      26  Timer_A0_StopPWM
       6  Timer_A1_ISR
       2  Timer_A1_ISR::??INTVEC 26
      28  Timer_A1_Init
      30  VLO_GetPeriod
      68  VLO_TimerCalibr
      10  VREF_Off
      14  VREF_On
       2  WDTCTL
      32  adc_data1
       1  adc_process
       1  amp_no
      18  calibr_sequence
       1  calibr_stage
       2  cfg_reg
       2  d1
       2  d2
       2  d3
       2  d4
       2  dark
       2  delta
       2  delta_last
       2  f
       1  fTimerA1_On
       1  fault_chain_ind
       2  fault_chain_timer
       1  fault_chamber_counter
       1  fault_phase
       8  fault_sequence
       2  fault_timer
     114  fir_filter
       2  flash_period_timer
       1  gain
      30  getTimerValue
      12  getZeroLevel
       2  hi_signal_counter
       1  jp1_state
       2  last_0_level
       2  last_level
       4  led_r
       4  led_sh
       4  led_y
       1  light_sync
       2  light_timer
    2404  main
       2  mainPeriodCounter
       6  q_array
       1  reference
      12  s_array
     200  signal_array
       2  start_timer
       1  strob_fault_phase
       2  strob_pulse_timer
       2  timerKeyDown
       2  timerLongPeriod
       2  timerMain
      18  watchdog_timer
       2  watchdog_timer::??INTVEC 20
      36  x
       2  zero_timer

 
 5 204 bytes in segment CODE
    50 bytes in segment DATA16_AN
    44 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
   372 bytes in segment DATA16_Z
    10 bytes in segment INTVEC
     2 bytes in segment REGVAR_AN
 
 5 204 bytes of CODE     memory
    45 bytes of CONST    memory (+ 10 bytes shared)
   373 bytes of DATA     memory (+ 50 bytes shared)
     0 bytes of REGISTER memory (+  2 bytes shared)

Errors: none
Warnings: 9
