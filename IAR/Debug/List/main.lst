###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           03/Nov/2017  11:32:53
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\ARTON-DL3\soft\current\main.c
#    Command line  =  
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\main.c -lcN
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\List -o
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\Obj --no_unroll
#        --no_inline --no_tbaa --debug -D__MSP430G2553__ -e --double=32
#        --regvar_r4 --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\430\lib\dlib\dl430fn.h" -I ..\ -I .\ -Om
#    List file     =  
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\List\main.lst
#    Object file   =  
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\Obj\main.r43
#
###############################################################################

E:\_ARTON_PROJ\ARTON-DL3\soft\current\main.c
      1          /**********************************************************************************
      2           *
      3           *      ASD-10QR MAIN routine
      4           * 
      5           **********************************************************************************
      6           * FileName:        main.c
      7           * Version:			1.00
      8           *
      9           * Processor:       MSP430G2xxx
     10           * Complier:        IAR Workbench for MSP430 v4.50 or higher
     11           *                  
     12           * Company:         ARTON
     13           *
     14           * Software License Agreement
     15           *
     16           * The software supplied herewith by ARTON Incorporated
     17           * (the "Company") for its devices is intended and
     18           * supplied to you, the Company's customer, for use solely and
     19           * exclusively on ARTON Inc products. The
     20           * software is owned by the Company and/or its Author, and is
     21           * protected under applicable copyright laws. All rights are reserved.
     22           * Any use in violation of the foregoing restrictions may subject the
     23           * user to criminal sanctions under applicable laws, as well as to
     24           * civil liability for the breach of the terms and conditions of this
     25           * license.
     26           *
     27           * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
     28           * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
     29           * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
     30           * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
     31           * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
     32           * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
     33           *
     34           *
     35           * Author               Date      	Version	  		Comment
     36           *--------------------------------------------------------------------------------
     37           * Oleg Semeniuk	 16.01.2014    	1.00		Release for v1.00
     38           *
     39           *********************************************************************************/
     40          
     41          
     42          /*********************************************************************************/
     43          /*                                 INCLUDES                                      */
     44          /*********************************************************************************/
     45          
     46          
     47          #include <stdio.h>                    /* standard I/O .h-file                */
     48          #include <string.h>                   /* string and memory functions         */
     49          
     50          #include  "hardware.h"
     51          #include  "main.h"
     52          #include  "flash.h"
     53          #include  "type.h"
     54          #include  "delay.h"
     55          #include  "soft_uart.h"
     56          
     57          
     58          /*********************************************************************************/
     59          /*                                 VARIABLES                                     */
     60          /*********************************************************************************/
     61          
     62          __regvar __no_init tFlags 	f 	 @ __R4; 	// Set of state machine flags
     63          
     64          //
     65          u16		timerMain;					// Текущее значение главного таймера
     66          //u16		mainPeriodCounter;			// Counter of main time period
     67          u16 	timerKeyDown;				// Для отслеживания нажатия на кнопку TEST
     68          u16		adc_data1[ADC_CH_DATA_LEN];	// Array for ADC samples
     69          
     70          u8 		DeviceMode; 				// Mode of device
     71          u8 		prevDeviceMode; 				// Mode of device to be restored from after TEST mode
     72          
     73          tFault	DeviceFault = {0};			// Current Faults flags
     74          tFault	prevDeviceFault = {0};			// previous Faults flags to be restored from after TEST mode
     75          
     76          tCalibrFault CalibrFault = {0};		// Calibration Faults flags
     77          u16 	dark;						// Level of dark signal
     78          u16 	delta;						// Current level signal
     79          
     80          u16 	delta_last = 0;				// Prev sygnal of delta
     81          u16		zero_timer = 0;				// Zero level signal timer
     82          
     83          u8		fault_chamber_counter = 0;	// Counter of series chamber fault
     84          //u8  	FireMeasCount = 0;			// Количество замеров, превышающих порог Пожара
     85          
     86          // Variables for definition Long Term Drift
     87          u16  	DriftCounter = 0;
     88          u32 	DriftSumma = 0;
     89          u32 	DriftLevel;					// Current Long Term Drift Level
     90          	
     91          //u16 	FireLimit;					// Current Limit of Fire
     92          //u16 	PreFireLimit;				// Current Limit of PreFire
     93          	
     94          u16		CCR1_Value;					// CCR1 PWM duty cycle for sound generation
     95          u8 		Timer50msCounter = 0;		// Counter of 50ms ticks
     96          
     97          
     98          s16		signal_array[SIGNAL_ARRAY_LEN];
     99          
    100          volatile u32		led_r;
    101          volatile u32		led_y;
    102          volatile u32		led_sh = 0;
    103          
    104          u8 		fTimerA1_On = 0;
    105          
    106          
    107          #define CALIBR_STAGES		6
    108          u8 		calibr_stage;
    109          u16		s_array[CALIBR_STAGES];
    110          u8		q_array[CALIBR_STAGES];
    111          
    112          
    113          const u8 calibr_sequence[CALIBR_STAGES][3] = {
    114          //			 Amp_No	Gain  Reference
    115          			{  1,    0,     2 },
    116          			{  2,    0,     1 },
    117          			{  2,    1,     1 },
    118          			{  2,    2,     1 },
    119          			{  2,    3,     1 },
    120          			{  2,    3,     0 },
    121          };
    122          //
    123          
    124          const u8 fault_sequence[4 * 2] = {MODE_FAULT, 10, MODE_NORM, 10, MODE_FIRE, 0, 0};	// 0 = ~~
    125          
    126          u8  fault_chain_ind = 0;	// 	
    127          u16 fault_chain_timer = 0;
    128          
    129          s8	gain;
    130          u8	amp_no;
    131          u8	reference;
    132          tCfgReg	cfg_reg;
    133          
    134          u8	jp1_state = 1;			// 0 - JP1 Open, 1 - JP1 Close
    135          
    136          u8	adc_process = 0;		// ADC low level semafore
    137          
    138          u16	light_timer = 0;		// For led lighting
    139          u8	light_sync = 0;			// For led lighting syncronisation
    140          
    141          u16	strob_pulse_timer = 0;	// Таймер ожидания электрической синхронизации
    142          u8	strob_fault_phase = 0;	// Фаза неисправности электрической синхронизации 0 - отключение БИ, 1 - включение БИ
    143          
    144          u16	hi_signal_counter  = 0;	// Very Hight signal counter
    145          
    146          u16	fault_timer = 0;		// Fault signal timer
    147          u8  fault_phase  = 0;		// Phase of  fault signal: 1 - break of BI , 0 - enable of  BI	
    148          
    149          u16 start_timer = 0;		// Start timer of device
    150          
    151          u16 flash_period_timer;		// Flast period timer
    152          
    153          u16 PWM_period = 0;
    154          
    155          
    156          
    157          /*********************************************************************************/
    158          /*                                FUNCTIONS                                      */
    159          /*********************************************************************************/
    160          // --- Declarations ---
    161          void ADC_MeasureInit(u8 input_no, u8 refer);
    162          u8   SignalAnalysis(void);
    163          void ADC_MeasureStart(void);
    164          void AMP_Calibration(void);
    165          
    166          u16  AverageData(u16 * data_ptr, u8 len);
    167          u8   RX_PacketParser(void);
    168          void ADC_Measure(u16 ch, u16 refout, u8 count);
    169          
    170          void Timer_A1_Init(void);
    171          void Timer_A0_SetDelay(u16 period);
    172          void Timer_A0_Off(void);
    173          void JP1_Define(void);
    174          
    175          
    176          
    177          
    178          //--------------------------------------------------------------------------------
    179          // Function		: void VLO_TimerCalibr(void)
    180          // Parameters	: None
    181          // Return		: None
    182          // Description	: Calculation calibration value of VLO timer
    183          //--------------------------------------------------------------------------------
    184          void VLO_TimerCalibr(void) {
    185          	u16 clk;
    186          	
    187          	// Start timer 1MHz
    188          	TACTL = TASSEL_2 + MC_1 + ID_3;     	 	// SMCLK, up mode  / 8
    189          	//			
    190          	CCR0 = 62500 - 1;	                    // Period 0.5sec
    191          	CCTL1 = 0; 			                    // CCR1 reset/set
    192          	TACCTL0 = CCIE;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    193          	//
    194          	clk = 0;
    195          	while (1) {
    196          		if (fTimer50msOn) {
    197          			fTimer50msOn = 0;
    198          			clk++;
    199          		}
    200          		if (fTimerA_On) {
    201          			fTimerA_On = 0;
    202          			clk++;
    203          			break;
    204          		}
    205          	}
    206          	//
    207          	//SoundStop();							// Disable interrupts of timer
    208          	TACTL = 0;  
    209          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    210          	//
    211          	if (clk != CONFIG->timer_calibr) {
    212          		StoragePropertyWord(eeTIMER_CALIBR_OFFSET, clk * 2);
    213          		#if (CRC_ENABLE == 1)
    214          		SavePropertyCS();
    215          		#endif
    216          	}
    217          	//
    218          }
    219          
    220          
    221          //--------------------------------------------------------------------------------
    222          // Function		: void ClearDriftVar(void)
    223          // Parameters	: None
    224          // Return		: None
    225          // Description	: Clear Long Term Drift variables
    226          //--------------------------------------------------------------------------------
    227          void ClearDriftVar(void) {
    228          	DriftCounter = 0;
    229          	DriftSumma = 0;
    230          	DriftLevel = 0;
    231          }
    232          
    233          
    234          
    235          //--------------------------------------------------------------------------------
    236          // Function		: void SetLimitCompens(void)
    237          // Parameters	: fire_level - fire level in increment
    238          // Return		: None
    239          // Description	: Setting limit compensation level
    240          //--------------------------------------------------------------------------------
    241          void SetLimitCompens(void) {
    242          	u16 norm = CONFIG->limit_norm;
    243          	//
    244          	StoragePropertyWord(eeLIMIT_LONG_DRIFT_OFFSET, norm / 2);
    245          	//
    246          #if (CRC_ENABLE == 1)
    247          	SavePropertyCS();
    248          #endif
    249          	//
    250          	ClearDriftVar();
    251          	//
    252          }
    253          
    254          
    255          
    256          //--------------------------------------------------------------------------------
    257          // Function		: void SetLevels(u16 norm)
    258          // Parameters	: norm - norm sygnal level 
    259          // Return		: None
    260          // Description	: Calculation and setting levels depending on background signal
    261          //--------------------------------------------------------------------------------
    262          void SetLevels(u16 norm) {
    263          	u16 temp;
    264          	u8  d;	
    265          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    266          	//
    267          	d = norm * 28 / 100;
    268          	//
    269          	temp = norm - d;		//
    270          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    271          	//
    272          	temp = norm - d * 3 / 4;		//
    273          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    274          	
    275          	//
    276          #if (CRC_ENABLE == 1)
    277          	SavePropertyCS();
    278          #endif
    279          	//
    280          	ClearDriftVar();
    281          	//
    282          }
    283          
    284          
    285          
    286          //--------------------------------------------------------------------------------
    287          // Function		: void SetLevels(u16 norm)
    288          // Parameters	: norm - norm sygnal level, nonlinearity_corr - correction 
    289          //				  nonlinearity in case of Hi signal (0 - none, 1 - low correction,
    290          //				  2 - hi correction)
    291          // Return		: None
    292          // Description	: Calculation and setting levels depending on background signal
    293          //--------------------------------------------------------------------------------
    294          void SetLevelsFromCalibr(u16 norm, u8 nonlinearity_corr) {
    295          	u16 temp;
    296          	u16  d;	
    297          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    298          	//
    299          	switch (nonlinearity_corr) {
    300          		case 0:
    301          			d = norm * 29 / 100;
    302          			break;
    303          		case 1:
    304          			d = norm * 23 / 100;
    305          
    306          			
    307          			break;
    308          		case 2:
    309          			d = norm * 18 / 100;
    310          			break;
    311          		default:
    312          			d = norm * 29 / 100;
    313          	}
    314          	//
    315          	temp = norm - d;		//
    316          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    317          	//
    318          	temp = norm - d * 3 / 4;		//
    319          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    320          	
    321          	//
    322          #if (CRC_ENABLE == 1)
    323          	SavePropertyCS();
    324          #endif
    325          	//
    326          	ClearDriftVar();
    327          	//
    328          }
    329          
    330          
    331          
    332          //--------------------------------------------------------------------------------
    333          // Function		: void DeviceStart(void)
    334          // Parameters	: None
    335          // Return		: None
    336          // Description	: Function executes initialization variable at start of device
    337          //--------------------------------------------------------------------------------
    338          void DeviceStart(void) {
    339          
    340          	DeviceFault.byte = 0;		// Reset faults flags
    341          	CalibrFault.byte = 0;		// Reset faults flags
    342          	//		
    343          	VLO_TimerCalibr();			// Calibration VLO Timer
    344          	//
    345          	ClearDriftVar();
    346          	
    347          }
    348          
    349          
    350          //--------------------------------------------------------------------------------
    351          // Function		: void DefineFireLimit(void)
    352          // Parameters	: None
    353          // Return		: None
    354          // Description	: Determination fire and prefire limits depending on long term drift
    355          //--------------------------------------------------------------------------------
    356          //#pragma optimize=none
    357          u16 getZeroLevel(void) {
    358          	u16 ret;
    359          
    360          //attenuation is more then 7dB (20%)
    361          	ret = CONFIG->limit_norm / 5;                   
    362          	return ret;
    363          }
    364          
    365          
    366          //--------------------------------------------------------------------------------
    367          // Function		: u16 getTimerValue(u16 period_sec)
    368          // Parameters	: time_sec : time in sec (0..655)
    369          // Return		: None
    370          // Description	: Getting time in system ticks
    371          //--------------------------------------------------------------------------------
    372          static u16 getTimerValue(u16 time_sec) {
    373          	u16 time = 100;
    374          	
    375          	if (time_sec > 655) return 0;
    376          	time *= time_sec;	
    377          	return time;
    378          }
    379          
    380          
    381          //--------------------------------------------------------------------------------
    382          // Function		: void VLO_TimerCalibr(void)
    383          // Parameters	: None
    384          // Return		: None
    385          // Description	: Calculation calibration value of VLO timer
    386          //--------------------------------------------------------------------------------
    387          u16 VLO_GetPeriod(void) {
    388          	
    389          	// Start timer 8MHz
    390          	TACTL = TASSEL_2 + MC_1;           	 	// SMCLK, up mode
    391          	//			
    392          	CCR0 =0xFFFF;                    		// Period 2.5mS
    393          	CCTL1 = 0; 			                    // CCR1 reset/set
    394          	TACCTL0 = 0;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    395          	//
    396          	while (fTimer50msOn == 0) {}
    397          	fTimer50msOn = 0;
    398          	//while (fTimer50msOn == 0) {}
    399          	
    400          	return TAR;
    401          }
    402          
    403          
    404          //--------------------------------------------------------------------------------
    405          // Function		: void VLO_TimerCalibr(void)
    406          // Parameters	: None
    407          // Return		: None
    408          // Description	: Calculation calibration value of VLO timer
    409          //--------------------------------------------------------------------------------
    410          void AMP_Gain_Init(void) {
    411          	
    412          	AMP_SetGain(CONFIG->Gain);
    413          	
    414          }
    415          
    416          #define ADC_AMP1	INCH_1		/* First AMP out */
    417          #define ADC_AMP2	INCH_0		/* Second AMP out */
    418          #define ADC_BUT		INCH_2		/* Tact button */
    419          #define ADC_AE		0x13		/* Analog (Input) Enable Control Register Value + VREF+*/
    420          #define ADC_AE_BUT	0x17		/* Analog (Input) Enable Control Register Value + Tact sw + VREF+*/
    421          
    422          #define ADC_FLUCTATION			20
    423          #define SIGNAL_0_LEVEL			512
    424          
    425          #define CORREL_LEVEL			120		/* Threshold level to correlations of the start signal */
    426          
    427          
    428          
    429          //--------------------------------------------------------------------------------
    430          // Function		: ADC_Measure(u8 input_no, u8 refer)
    431          // Parameters	: input_no - number AMP output (= 1 or 2), refer - reference voltage (=0 - 1.5V, =1 - 2.5V, =2 - 3.3V)
    432          // Return		: None
    433          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    434          //				   ~109 kS/s for 16 MHz 
    435          //--------------------------------------------------------------------------------
    436          void ADC_MeasureInit(u8 input_no, u8 refer) {
    437          	
    438          	ADC10CTL0 &= ~ENC;
    439          	while (ADC10CTL1 & BUSY);             	// Wait if ADC10 core is active 
    440          	//
    441          	switch ((Ref_Type)refer) {
    442          		case REF_1_5V:  
    443          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE;				// Sample&hold = 8 x ADC10CLKs
    444          			break;
    445          		case REF_2_5V:  
    446          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    447          			break;
    448          		case REF_3_3V:  
    449          			ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC + ADC10ON + ADC10IE  + REFOUT + REFON + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    450          			break;
    451          	}
    452          	//
    453          	DelayUs(50);	
    454          	//
    455          	ADC10DTC1 = SIGNAL_ARRAY_LEN;	//ADC_SAMPLES_NUMBER;			// count of conversions
    456          	//
    457          	if (input_no == 1) {
    458          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP1;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 1
    459          	}else{
    460          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP2;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 2
    461          	}
    462          	
    463          	ADC10AE0 |= ADC_AE;                     // A0 & A1 ADC option select
    464          	//
    465          }
    466          
    467          
    468          //--------------------------------------------------------------------------------
    469          // Function		: ADC_Measure(u16 ch, u16 refout, u8 count)
    470          // Parameters	: ch - ADC channel, refout - 0 or REFOUT, count - кол-во измерений 
    471          // Return		: None
    472          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    473          //--------------------------------------------------------------------------------
    474          void ADC_MeasureStart(void) {
    475          	__disable_interrupt();		// Disable interrupt
    476          	
    477          	adc_process = 1;
    478          	
    479          	//ADC10SA = (u16) &signal_array[SIGNAL_ARRAY_LEN - ADC_SAMPLES_NUMBER];      	// Data buffer start - end of sygnal_array
    480          	ADC10SA = (u16) &signal_array[0];	// Data buffer start - end of sygnal_array
    481          	ADC10CTL0 |= ENC + ADC10SC;         // Sampling and conversion start
    482          	//
    483          
    484          	__enable_interrupt();                     // enable interrupts
    485          }
    486          
    487          u16 last_0_level;
    488          u16 last_level;
    489          
    490          //--------------------------------------------------------------------------------
    491          // Function		: void VLO_TimerCalibr(void)
    492          // Parameters	: None
    493          // Return		: 0 - no valid array, 1
    494          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    495          //--------------------------------------------------------------------------------
    496          u16 AbsValue(u16 x1, u16 x2) {
    497          	if (x1 >= x2) {
    498          		return (x1 - x2);
    499          	}else{
    500          		return (x2 - x1);
    501          	}
    502          }
    503          
    504          /**************************************************************
    505          WinFilter version 0.8
    506          http://www.winfilter.20m.com
    507          akundert@hotmail.com
    508          
    509          Filter type: Band Pass
    510          Filter model: Butterworth
    511          Filter order: 8
    512          Sampling Frequency: 109 KHz
    513          Fc1 and Fc2 Frequencies: 3.800000 KHz and 14.000000 KHz
    514          Coefficents Quantization: 8-bit
    515          
    516          Z domain Zeros
    517          z = -1.000000 + j 0.000000
    518          z = -1.000000 + j 0.000000
    519          z = -1.000000 + j 0.000000
    520          z = -1.000000 + j 0.000000
    521          z = -1.000000 + j 0.000000
    522          z = -1.000000 + j 0.000000
    523          z = -1.000000 + j 0.000000
    524          z = -1.000000 + j 0.000000
    525          z = 1.000000 + j 0.000000
    526          z = 1.000000 + j 0.000000
    527          z = 1.000000 + j 0.000000
    528          z = 1.000000 + j 0.000000
    529          z = 1.000000 + j 0.000000
    530          z = 1.000000 + j 0.000000
    531          z = 1.000000 + j 0.000000
    532          z = 1.000000 + j 0.000000
    533          
    534          Z domain Poles
    535          z = 0.644814 + j -0.260807
    536          z = 0.644814 + j 0.260807
    537          z = 0.756494 + j -0.196546
    538          z = 0.756494 + j 0.196546
    539          z = 0.587475 + j -0.386644
    540          z = 0.587475 + j 0.386644
    541          z = 0.840396 + j -0.195195
    542          z = 0.840396 + j 0.195195
    543          z = 0.588237 + j -0.523443
    544          z = 0.588237 + j 0.523443
    545          z = 0.901607 + j -0.202202
    546          z = 0.901607 + j 0.202202
    547          z = 0.951542 + j -0.212108
    548          z = 0.951542 + j 0.212108
    549          z = 0.642148 + j -0.658914
    550          z = 0.642148 + j 0.658914
    551          ***************************************************************/
    552          
    553          #define Ntap 18
    554          
    555          // !!! See division by DCgain below
    556          #define DCgain 512	
    557          
    558          //const s16 FIRCoef[Ntap] = { 
    559          const s8 FIRCoef[Ntap] = { 
    560                    -13,
    561                    -32,
    562                    -52,
    563                    -59,
    564                    -43,
    565                     -2,
    566                     50,
    567                     95,
    568                    113,
    569                     95,
    570                     50,
    571                     -2,
    572                    -43,
    573                    -59,
    574                    -52,
    575                    -32,
    576                    -13,
    577                     -3
    578          };
    579          
    580          
    581          static s16 	x[Ntap] = {0};	//, 512, 512, 512 }; 	//input samples
    582          
    583          s16 fir_filter(s16 sample) {
    584              s32	 		y = 0;      //output sample
    585              int 		i;
    586          	
    587              // Shift the old samples
    588          __disable_interrupt();
    589              for(i = Ntap-1; i > 0; i--) {
    590          		x[i] = x[i-1];
    591          	}
    592          	
    593              // Calculate the new output
    594              x[0] = sample;
    595              for(i = 0; i < Ntap; i++) {
    596          		y += (s32)FIRCoef[i] * x[i];
    597          	}
    598          	
    599          	if (y >= 0) {
    600          		y = y >> 9;
    601          	}else{
    602          		y = y / DCgain;	
    603          	}
    604          __enable_interrupt();	
    605              return y;	// / DCgain;
    606          }
    607          
    608          
    609          //s16	adc_back1[ADC_SAMPLES_NUMBER];
    610          
    611          volatile s16	d1, d2, d3, d4;
    612          
    613          #define EXT_ARRAY_LEN	7
    614          
    615          //--------------------------------------------------------------------------------
    616          // Function		: void VLO_TimerCalibr(void)
    617          // Parameters	: None
    618          // Return		: 0 - no signal, 1 - signal is existing
    619          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    620          //--------------------------------------------------------------------------------
    621          //#pragma optimize=none
    622          u8 SignalAnalysis(void) {
    623          	int i;
    624          	s16	sample;
    625          	s16 min = 2048, max = -2048;
    626          //	int i_min = 0, i_max = 0;
    627          	u8 array_hi[EXT_ARRAY_LEN] = {0};
    628          	u8 array_lo[EXT_ARRAY_LEN] = {0};
    629          	u8 i_hi = 0;
    630          	u8 i_lo = 0;
    631          	s8 T = 0;
    632          	u8 ret = 0;
    633          	
    634          	// 
    635              for(i = 1; i < Ntap; i++) {
    636          		x[i] = 0;	//signal_array[i] - 220;
    637          	}
    638          	
    639          	sample = AverageData((u16 *)&signal_array[0], 16);
    640          	
    641          	// Filtering with use FIR
    642          	for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
    643          		//signal_array[i] = fir_filter(adc_data1[j++] - 512);
    644          		signal_array[i] = fir_filter(signal_array[i] - sample);	
    645          	}
    646          	
    647          	
    648          	// Searching for of importance of the amplitude of the signal on possible gap of time
    649          	for (i = 10; i < SIGNAL_ARRAY_LEN - 2; i++) {
    650          		sample = signal_array[i];
    651          		if (((sample >  signal_array[i - 1]) && (sample >  signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) ||
    652          		    ((sample >  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) || 
    653          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) )   {
    654          	
    655          			if (sample > 10) {	
    656          				array_hi[i_hi] = i;
    657          				if (i_hi < EXT_ARRAY_LEN - 1) i_hi++;
    658          			}
    659          			
    660          			
    661          		}
    662          		
    663          		if (((sample <  signal_array[i - 1]) && (sample <  signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) ||
    664          		    ((sample <  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) || 
    665          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) )   {
    666          		
    667          			if (sample < (-10)) {	
    668          				array_lo[i_lo] = i;
    669          				if (i_lo < EXT_ARRAY_LEN - 1) i_lo++;
    670          			}
    671          			
    672          		}
    673          			
    674          		if (sample < min) {
    675          			min = sample;
    676          //			i_min = i;
    677          		}
    678          		if (sample > max) {
    679          			max = sample;
    680          //			i_max = i;
    681          		}
    682          	}
    683          
    684          	//
    685          	delta = 0;
    686          	
    687          	if ((i_lo < 2) || (i_hi < 3)) {
    688          		// Low signal
    689          		ret = 1;
    690          	}else{
    691          		T = array_hi[1] - array_hi[0];
    692          		if ((T < 9) || (T > 15))  {
    693          			// High signal
    694          			ret = 2;
    695          		}
    696          	}
    697          	
    698          	d1 = signal_array[array_hi[0]] - signal_array[array_hi[1]];
    699          	if (((d1 < -50) || (d1 > 50)) && (amp_no == 1)){
    700          		// Wery high signal
    701          		ret = 2;
    702          	}
    703          	
    704          	// Definition of delta
    705          	// Define of first low extremum after first hi extremum
    706          	for (i = 0; i < EXT_ARRAY_LEN; i++) {
    707          		if (array_lo[i] > array_hi[0]) {
    708          			i_hi = 0;
    709          			i_lo = i;
    710          			break;
    711          		}
    712          	}
    713          	//
    714          
    715          	
    716          	//i_lo++;
    717          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    718          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo++]];
    719          	d3 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    720          	d4 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    721          
    722          	delta = (d1 + d2 + d3 + d4) / 4;
    723          	
    724          	PWM_period = delta;
    725          	
    726          	if (delta > 4000) {
    727          		delta = 0;	//CONFIG->limit_norm;
    728          	}
    729          	
    730          	if ((DeviceMode == MODE_CALIBR) && ret) {
    731          		delta = 0;
    732          	}
    733          	//
    734          	return ret;
    735          }
    736          
    737          //--------------------------------------------------------------------------------
    738          // Function		: void Timer_A0_SetDelay(u16 period)
    739          // Parameters	: period in us (1..65535) - for 8 MHz DCO
    740          // Return		: None
    741          // Description	: Function initiates delay
    742          //--------------------------------------------------------------------------------
    743          void Timer_A0_SetDelay(u16 period) {
    744          	
    745          	if (period == 0) return;
    746          	
    747          	_BIC_SR(GIE);    					// Запрещаем прерывания
    748          	
    749          	fTimerA_Enable = 1;
    750          	fTimerA_Repeat = 0;
    751          	//
    752          	TA0R = 0;
    753          	TACTL 	 = TASSEL_2 + MC_1 + ID_3;  // SMCLK, up mode, div = 8
    754          	CCR0 	 = period - 1;      		// Period T(us) * F(MHz)
    755                  CCR1 	 = 0;      		// Period T(us) * F(MHz)
    756          	TACCTL0 = CCIE;						// Разрешаем прерывание таймера по достижению значения TACCCR0.
    757          	//
    758          	_BIS_SR(GIE);    					// Разрешаем прерывания
    759          }
    760          //--------------------------------------------------------------------------------
    761          // Function		: void Timer_A0_StartPWM(u16 PulseWidth)
    762          // Parameters	: PulseWidth in us (1..65535) - for 8 MHz DCO
    763          // Return		: None
    764          // Description	: Function initiates PWM 
    765          //--------------------------------------------------------------------------------
    766          #define PWM_PWRIOD      1024
    767          void Timer_A0_StartPWM(u16 PulseWidth){	
    768            u16 tmp = PWM_PWRIOD/PulseWidth;
    769            
    770            if ((PulseWidth == 0) || (f.bTimerA_On == 1) || (f.bTimerA_Repeat ==1))return;
    771          
    772          	_BIC_SR(GIE);    					// Запрещаем прерывания
    773          
    774          	P1SEL |= TEST_OUT_BIT;
    775                  
    776          	if (BCSCTL1 == CALBC1_8MHZ)
    777              TACTL = TASSEL_2 + MC_1 + ID_3;      // SMCLK, up mode, div = 8
    778            else
    779              if(BCSCTL1 == CALBC1_1MHZ)
    780            
    781            TACTL = TASSEL_2 + MC_1;            // SMCLK, up mode, div = 1
    782            TACCTL1 = OUTMOD_7;
    783          //        CCR0 	 = PWM_PWRIOD - 1;
    784          //        CCR1 	 = PulseWidth - 1;      		// Period T(us) * F(MHz)
    785            CCR1 	 = CCR0/tmp;      		// Period T(us) * F(MHz)
    786          
    787            _BIS_SR(GIE);    				// Разрешаем прерывания
    788          }
    789          
    790          void Timer_A0_StopPWM(void){	
    791          	_BIC_SR(GIE);    				// Запрещаем прерывания
    792          	
    793          	P1SEL &= ~TEST_OUT_BIT;
    794          	TEST_OUT_CLR();
    795                  
    796          	CCR0 	 = 0;
    797          	fPWMEnabled = 0;
    798          
    799          	_BIS_SR(GIE);    					// Разрешаем прерывания
    800          }
    801          
    802          void Timer_A0_SetPWMPulse(u16 Pulse){	
    803            
    804          	if (Pulse == 0) return;
    805          	
    806          	_BIC_SR(GIE);    					// Запрещаем прерывания
    807          	CCR0 	 = PWM_PWRIOD - 1;
    808          	CCR1 	 = Pulse - 1;      		// Period T(us) * F(MHz)
    809          	//
    810          	_BIS_SR(GIE);    					// Разрешаем прерывания
    811          }
    812          
    813          //--------------------------------------------------------------------------------
    814          // Function		: void TimerA1_DelayUs(u16 time)
    815          // Parameters	: period in us (1..32768) - for 1 MHz DCO
    816          // Return		: None
    817          // Description	: Function initiates 
    818          //--------------------------------------------------------------------------------
    819          #pragma optimize=none
    820          void TimerA1_DelayUs(u16 time) {
    821          	_BIC_SR(GIE);    					// Запрещаем прерывания
    822          	
    823          	//
    824          	TA1R = 0;
    825          	TA1CTL 	 = TASSEL_2 + MC_1;     	// SMCLK, up mode, div = 8
    826          	TA1CCR0 	 = time - 1 - 35;      	// Period T(us) * F(MHz)
    827          	//
    828          	_BIS_SR(GIE);    					// Разрешаем прерывания
    829          	
    830          	while ((TA1CCTL0 & CCIFG) == 0);
    831          	
    832          	TA1CTL 	 = 0;
    833          	TA1CCTL0 = 0;
    834          
    835          }
    836          
    837          
    838          //--------------------------------------------------------------------------------
    839          // Function		: void Timer_A1_Init(void)
    840          // Parameters	: period in us (1..65535) - for 1 MHz DCO
    841          // Return		: None
    842          // Description	: Function initiates delay
    843          //--------------------------------------------------------------------------------
    844          void Timer_A1_Init(void) {
    845          	_BIC_SR(GIE);    					// Запрещаем прерывания
    846          	//
    847          	TA1R = 0;
    848          	TA1CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    849          	TA1CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    850          	TA1CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
    851          	//
    852          	_BIS_SR(GIE);    					// Разрешаем прерывания
    853          }
    854          
    855          
    856          //--------------------------------------------------------------------------------
    857          // Function		: void SoundStart(u8 snd_ind)
    858          // Parameters	: period in us (1..32768) - for 16 MHz DCO
    859          // Return		: None
    860          // Description	: Function initiates 
    861          //--------------------------------------------------------------------------------
    862          void Timer_A0_Off(void) {
    863          	_BIC_SR(GIE);    			// Запрещаем прерывания
    864          	//	
    865          	fTimerA_Enable = 0;
    866          	fTimerA_Repeat = 0;
    867          	//
    868                  P1SEL &= ~TEST_OUT_BIT;
    869                  TEST_OUT_CLR();
    870                  
    871          	TACTL = 0;  
    872          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    873          	//
    874          	_BIS_SR(GIE);    			// Разрешаем прерывания
    875          
    876          }
    877          
    878          
    879          //--------------------------------------------------------------------------------
    880          // Function		: void SetFaultMode(void)
    881          // Parameters	: None
    882          // Return		: None
    883          // Description	: 
    884          //--------------------------------------------------------------------------------
    885          void SetFaultMode(void) {
    886          	
    887          	DeviceMode = MODE_FAULT;
    888          	//
    889          
    890          	if (fault_timer == 0) { 
    891          		// No faults
    892          		fault_timer = 1000;		// 10 sec
    893          		fault_phase = 1;		// Break of BI
    894          	}
    895          
    896          	//
    897          //	strob_pulse_timer = 0;		// Clear strob timer because there is breaking BI
    898          }
    899          
    900          
    901          
    902          //--------------------------------------------------------------------------------
    903          // Function		: void FaultSignalManager(void)
    904          // Parameters	: None
    905          // Return		: None
    906          // Description	: Call one time per 10 ms
    907          //--------------------------------------------------------------------------------
    908          void FaultSignalManager(void) {
    909          	
    910          	if ((DeviceMode == MODE_FIRE) || (DeviceMode == MODE_TEST) || (DeviceMode == MODE_CALIBR)) {
    911          		return;
    912          	}
    913          	//
    914          	if (DeviceFault.byte) {
    915          		DeviceMode = MODE_FAULT;
    916          		led_r = 0;
    917          
    918          		if (DeviceFault.fSignal_Low) {
    919          			// Level signal is very low
    920          			led_y = LED_PULSE_1;
    921          		}else	
    922          		if (DeviceFault.fFaultDrift) {
    923          			// Long Term Drift fault
    924          		led_y = LED_PULSE_3;
    925          		}else	
    926          		if (DeviceFault.fSignal_Hi) {
    927          		// Level signal is very big
    928          		led_y = LED_PULSE_5;
    929          		}
    930          	}
    931          	
    932          	if (CalibrFault.byte) {
    933          		// Calibration fault signals
    934          		
    935          		DeviceMode = MODE_FAULT;
    936          		led_r = 0;
    937          		
    938          		if (CalibrFault.fCalibr_Low) {
    939          			led_y = LED_PULSE_4;
    940          		}else
    941          		if (CalibrFault.fCalibr_Hi) {
    942          			led_y = LED_PULSE_5;
    943          		}
    944          
    945          		fault_timer = 0;
    946          		fault_phase = 0;
    947          	}
    948          		
    949          	if ((DeviceFault.byte == 0) && (CalibrFault.byte == 0)) {
    950          		if (DeviceMode == MODE_FAULT) {
    951          			DeviceMode = MODE_NORM;
    952          			
    953          			led_r = 0;
    954          			led_y = 0;
    955          			fault_timer = 0;
    956          			fault_phase = 0;
    957           
    958          			NFAULT_SET();
    959          
    960          		}
    961          	}
    962          	//
    963          
    964          	if (fault_timer) {
    965          		fault_timer--;
    966          		//
    967          		if (fault_timer == 0) {
    968          			if (fault_phase) {
    969          				fault_phase = 0;
    970          				fault_timer = 2000;		// 20 sec
    971          			}else{
    972          				fault_phase = 1;
    973          				fault_timer = 1000;		// 10 sec
    974          			}
    975          		}
    976          		//
    977          		if (fault_phase == 1) {
    978          			NFAULT_CLR();
    979          		}else{
    980          			NFAULT_SET();
    981          		}
    982          	}
    983          }
    984          
    985          
    986          //--------------------------------------------------------------------------------
    987          // Function		: void LedTestValueManager(void)
    988          // Parameters	: None
    989          // Return		: None
    990          // Description	: 
    991          //--------------------------------------------------------------------------------
    992          //#pragma optimize=none
    993          void LedTestValueManager(void) {
    994          	if (delta < 150) {
    995          		led_r = LED_PULSE_1;
    996          		led_y = LED_FULL;
    997          	}else
    998          	if (delta < 250) {
    999          		led_r = LED_PULSE_2;
   1000          		led_y = LED_FULL;
   1001          	}else
   1002          	if (delta < 450) {
   1003          		led_r = LED_PULSE_3;
   1004          		led_y = LED_FULL;
   1005          	}else
   1006          	if (delta < 550) {
   1007          		led_r = LED_PULSE_4;
   1008          		led_y = LED_FULL;
   1009          	}else{
   1010          		led_r = LED_PULSE_5;
   1011          		led_y = LED_FULL;
   1012          	}
   1013          }
   1014          
   1015          
   1016          //---------------------------------------------------------------------------------
   1017          // Function		: void AMP_SetGain(u8 value)
   1018          // Parameters	: None
   1019          // Return		: None
   1020          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1021          //---------------------------------------------------------------------------------
   1022          void ADC_SetParam(void) {
   1023          	gain = CONFIG->Gain & 0x0F;
   1024          	reference = CONFIG->Gain >> 4;
   1025          	amp_no = CONFIG->AMP_No;
   1026          }
   1027          
   1028          //---------------------------------------------------------------------------------
   1029          // Function		: void AMP_SetGain(u8 value)
   1030          // Parameters	: None
   1031          // Return		: None
   1032          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1033          //---------------------------------------------------------------------------------
   1034          #pragma optimize=none
   1035          void CalibrationResultAnalise(void) {
   1036          	int i;
   1037          	u16 prev, temp, min = 0xFFFF, max = 0;
   1038          	u8  i_ok = 0xFF, i_ok2 = 0xFF;
   1039          	u8  fault = 0;
   1040          	u16 d;
   1041          	u8  corr = 0;
   1042          	
   1043          	prev = s_array[0];
   1044          	for (i = 0; i < CALIBR_STAGES; i++) {
   1045          		temp = s_array[i];
   1046          		//
   1047          		if (temp > max) {
   1048          			max = temp;
   1049          		}
   1050          		if (temp < min) {
   1051          			min = temp;
   1052          		}
   1053          			
   1054          		if (((temp >= 90) && (temp <= 200)) || 
   1055          			((temp >= 480) && (temp <= 600))) {
   1056          			i_ok = i;
   1057          			break;
   1058          		}
   1059          		if ((temp >= 200) && (temp <= 480)) {
   1060          			i_ok2 = i;
   1061          			break;
   1062          		}
   1063          		//
   1064          		if ((prev > 100) && (temp == 0) && (i <= 4)) {
   1065          			fault = 1;	// Signal is vefy Hi
   1066          		}
   1067          		prev = temp;
   1068          	}
   1069          	//
   1070          	if (q_array[0] == 2) {
   1071          		// Signal is vefy Hi
   1072          		fault = 1;
   1073          	}
   1074          	//
   1075          		
   1076          	if (fault) {
   1077          		// End of calibration - very Hi signal - ERROR
   1078          		//DeviceFault.fSignal_Hi = 1;
   1079          		//DeviceMode = MODE_FAULT;
   1080          		CalibrFault.fCalibr_Hi = 1;
   1081          	}else
   1082          	if ((i_ok2 < CALIBR_STAGES) || (i_ok < CALIBR_STAGES)) {
   1083          		if (i_ok2 < CALIBR_STAGES) {
   1084          			i = i_ok2; 
   1085          		}else{
   1086          			i = i_ok;
   1087          		}
   1088          		//
   1089          		// Calibration Ok!!!
   1090          		//
   1091          		d = s_array[i];
   1092          		//q = q_array[i]; 
   1093          		//
   1094          
   1095          	
   1096          		if (i == 0) {
   1097          			if (d >= 480) {
   1098          				CalibrFault.fCalibr_Hi = 1;
   1099          				StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1100          				return;
   1101          			}
   1102          			//
   1103          
   1104          			if (d >= 330) {
   1105          				corr = 2;
   1106          			}else
   1107          			if (d >= 170) {
   1108          				corr = 1;
   1109          			}
   1110          
   1111          		}
   1112          /*
   1113          			if (CALIBR_STAGES - 2 <= i)
   1114          		{
   1115          			corr = 1;
   1116          		}
   1117          	*/		
   1118          		// That's Ok
   1119          		//SetLevels(d);
   1120          		SetLevelsFromCalibr(d, corr);
   1121          		SetLimitCompens();
   1122          		
   1123          		amp_no = calibr_sequence[i][0];
   1124          		gain = calibr_sequence[i][1];
   1125          		reference = calibr_sequence[i][2];
   1126          		
   1127          		StoragePropertyByte(ee_GAIN, gain + (reference << 4));
   1128          		StoragePropertyByte(ee_AMP_NO, amp_no);
   1129          		StoragePropertyWord(eeCONFIG_REG_OFFSET, cfg_reg.word);
   1130          		//
   1131          		DeviceMode = MODE_NORM;
   1132          
   1133          //DL3   
   1134          		NFAULT_SET();
   1135          
   1136          
   1137          		//
   1138          		AMP_SetGain(gain);
   1139          		//
   1140          	}else
   1141          	if (max < SYGNAL_MIN_VALUE) {
   1142          		// Signal is Low
   1143          		CalibrFault.fCalibr_Low = 1;
   1144          	}else
   1145          	if (min > SYGNAL_MAX_VALUE) {
   1146          		// Signal is Hi
   1147          		CalibrFault.fCalibr_Hi = 1;
   1148          	}
   1149          	//
   1150          //DL3   
   1151          		NFAULT_SET();
   1152          	StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1153          }
   1154          	
   1155          
   1156          //========================================================
   1157          //                 ---  M A I N  ----
   1158          //========================================================
   1159          //--------------------------------------------------------------------------------
   1160          // Function		: void main(void)
   1161          // Parameters	: None
   1162          // Return		: None
   1163          // Description	: Main function. Contains main loop.
   1164          //--------------------------------------------------------------------------------
   1165          void main(void) {
   1166          	u8	byte, sh, len, irpulses = 3, fADCStarted = 0;
   1167          	int i;
   1168          	u8  loc_buf[2];
   1169          	u8  n_counter = 0;
   1170          	u8  quality;
   1171          	u16	summa = 0;
   1172          	u8	fire_level_counter = 0;
   1173          	u8	QualityFaultCounter = 0;
   1174          	u8	led_clk;
   1175          	u16	led_timer = 0;
   1176          	u8	timerA1_blank = 0;
   1177          	
   1178          	// Initialization variables and GPIO
   1179          	WDTCTL = WDTPW + WDTHOLD;				// отключаем сторожевой таймер
   1180          	// GIPIO Init
   1181          	GPIO_Init();
   1182          		
   1183          	// Init internal RC osc.
   1184          	BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1185          	DCOCTL =  CALDCO_1MHZ;
   1186          	
   1187          	DelayMs(100);
   1188          	
   1189          	// Initialization code for VLO
   1190          	__set_R4_register(0);
   1191          	//
   1192          	BCSCTL3 |= LFXT1S_2;                    // Select VLO as low freq clock
   1193          	// End initialization code
   1194          	
   1195          	WDTCTL = WDT_ADLY_16;                   // Interval timer	/* for 50 ms */
   1196          	//WDTCTL = WDT_ADLY_1_9;                   // Interval timer	/* for 5.9 ms */
   1197          	IE1 |= WDTIE;                           // Enable WDT interrupt
   1198          	//
   1199          	if (IFG1 & WDTIFG) {
   1200          		// Reset WDT
   1201          		#if (SYS_FAULT_ENABLE == 1)
   1202          		DeviceFault.fFaultSWReset = 1;
   1203          		#endif
   1204          	}
   1205          	IFG1 = 0;
   1206          	//	
   1207          	DeviceMode = MODE_NORM;
   1208          	
   1209          	//!!!!
   1210          	CH_IN_DIR |= CH_IN_BIT;
   1211                  
   1212          //DL3   
   1213                  NFAULT_SET();
   1214          //        fPWMEnabled = 0;
   1215          //DL3   	
   1216          	DelayMs(4000);
   1217                  
   1218          	Led_Flash(1);
   1219          	DelayMs(300);
   1220          	Led_Flash(1);
   1221          	
   1222          //	BREAK_DISABLE();					// Enable BI
   1223          	DelayMs(1000);
   1224          	
   1225          	_BIS_SR(GIE);    					// Interrupt enable
   1226          	DeviceStart();
   1227          
   1228          
   1229          
   1230          	AMP_SetGain(CONFIG->Gain);
   1231          	ADC_SetParam();
   1232          	cfg_reg = CONFIG->config_reg;
   1233          	
   1234          	Timer_A1_Init();
   1235          	
   1236          //	DelayMs(2000);
   1237          	
   1238          	start_timer = 400;		// 4 sec
   1239          // *****************************************************************
   1240          // ******************   M A I N   L O O P  *************************
   1241          // *****************************************************************
   1242          	while(1) {
   1243          		//-------------------------------------------------------------------------------
   1244          		//
   1245          		// ******** Обработчики событий ********
   1246          		//
   1247          		//-------------------------------------------------------------------------------
   1248          		
   1249          //-------------------------------------------------------------------------------
   1250          // TimerA0 Event		
   1251          //-------------------------------------------------------------------------------
   1252                    
   1253          		if (fTimerA_On) {				// Закончен период ожидания измерительных импульсов
   1254          			fTimerA_On = 0;
   1255                            
   1256                BCSCTL1 = CALBC1_16MHZ; 	// Используем частоту 16 MГц
   1257                DCOCTL =  CALDCO_16MHZ;
   1258                                    //
   1259                TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1260                                    //
   1261                Timer_A0_Off();				
   1262                                    
   1263                ADC_MeasureStart();
   1264                                    
   1265                fADCStarted =1;
   1266                                    
   1267          
   1268                timerA1_blank = 0;
   1269            //Added for DL3
   1270          			if(1 == fADCStarted){
   1271                	fADCStarted = 0;
   1272          				while(irpulses){
   1273          					IRED_SET();
   1274          					DelayUs(1000);
   1275          					IRED_CLR();
   1276          					DelayUs(1000);
   1277          					irpulses--;
   1278          				}
   1279          				irpulses = 3;
   1280          			}
   1281          
   1282          		}
   1283          
   1284          //-------------------------------------------------------------------------------
   1285          // fTimer50msOn Event				
   1286          //-------------------------------------------------------------------------------
   1287          		if (fTimer50msOn) {		// Получен следующий 50мс интервал
   1288          			fTimer50msOn = 0;
   1289          			//
   1290          			Timer50msCounter = 0;
   1291          		}
   1292          		
   1293          //-------------------------------------------------------------------------------
   1294          // TimerA1 Event (SysTick) 10 ms
   1295          //-------------------------------------------------------------------------------
   1296          		if (fTimerA1_On) {				// Получен следующий интервал timer
   1297          			fTimerA1_On = 0;
   1298          			
   1299          			if(start_timer){
   1300                  start_timer--;
   1301                  if (start_timer == 0) {
   1302                  CalibrFault.byte = CONFIG->calibr_fault;
   1303                  flash_period_timer = 500;	// Need flash after 5 sec
   1304                  strob_pulse_timer = 0;
   1305          				}
   1306          			}
   1307          			
   1308          			if (timerKeyDown) {
   1309          				timerKeyDown++;
   1310          				if (timerKeyDown > 200 ) {			// > 2 sec - Start Calibration
   1311          
   1312          					// CALIBRATION Start
   1313          					JP1_Define();			// Define JP1 on BVS state
   1314          					if (jp1_state == 0) {
   1315          						// JP1 is Open 
   1316          						cfg_reg.fDrift = 1;
   1317          					}else{
   1318          						cfg_reg.fDrift = 0;
   1319          					}
   1320                                                  
   1321          					//
   1322          					// Calibration mode init 
   1323          					DeviceMode = MODE_CALIBR;
   1324          					fPWMEnabled = 1;
   1325          
   1326          					// Calibration from most amp to small
   1327          //DL3			
   1328          					NFAULT_SET();
   1329          
   1330          					DeviceFault.fStrobNone = 0;
   1331          					strob_pulse_timer = 0;
   1332          
   1333          					calibr_stage = 0;
   1334          					n_counter = 0;
   1335          					summa = 0;
   1336          					//
   1337          					amp_no = calibr_sequence[calibr_stage][0];
   1338          					gain = calibr_sequence[calibr_stage][1];
   1339          					reference = calibr_sequence[calibr_stage][2];
   1340          					//
   1341          					AMP_SetGain(gain);
   1342          					
   1343          					QualityFaultCounter = 0;
   1344          					DeviceFault.byte = 0;
   1345          					CalibrFault.byte = 0;
   1346          					fault_timer = 0;
   1347          					fault_phase = 0;
   1348          					
   1349          					RED_CLR();
   1350          					YEL_CLR();
   1351          					
   1352          					timerKeyDown = 0;
   1353          					
   1354          					flash_period_timer = 120;	// Flash after 1.2 sec
   1355          					light_timer = 7;			// Value - the power of LED light
   1356          				}
   1357          			}
   1358          			
   1359          			if (zero_timer) {
   1360          				zero_timer++;
   1361          			}
   1362          				
   1363          			if (fault_chain_timer)  {
   1364          				fault_chain_timer--;
   1365          				if (DeviceMode != MODE_FIRE) {
   1366          					if (fault_chain_timer == 0) {
   1367          						if (fault_sequence[fault_chain_ind] == 0) {
   1368          							fault_chain_ind = 0;
   1369          							DeviceMode = MODE_NORM;
   1370          						}else{
   1371          							DeviceMode = fault_sequence[fault_chain_ind++];
   1372          							fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1373          							//
   1374          							switch (DeviceMode) {
   1375          								case MODE_FIRE:
   1376          									FIRE_SET();
   1377          									//
   1378          									RED_SET();
   1379          									YEL_CLR();
   1380          									fault_chain_timer = 0;
   1381          
   1382          									zero_timer = 0;
   1383          									DeviceFault.fSignal_Low = 0;
   1384          									break;
   1385          								case MODE_FAULT:
   1386          										NFAULT_CLR();
   1387                              break;
   1388          								case MODE_NORM:
   1389          										zero_timer = 0;
   1390          										DeviceFault.fSignal_Low = 0;
   1391          										NFAULT_SET();
   1392          							}
   1393          						}
   1394          					}
   1395          				}
   1396          			}
   1397          			
   1398          			if (timerMain) {
   1399          				timerMain--;
   1400          				if (timerMain == 0) {
   1401          					if (DeviceMode == MODE_TEST) {
   1402          						DeviceMode = MODE_NORM;
   1403          						RED_CLR();
   1404          						YEL_CLR();
   1405          						
   1406          						NFAULT_SET();
   1407          					}
   1408          				}
   1409          			}
   1410          			//
   1411          			// Setting signals in Fault Mode (LEDs and other pins)
   1412          			FaultSignalManager();
   1413          			//
   1414          			
   1415          			if (timerA1_blank) {
   1416          				timerA1_blank--;
   1417          			}else{
   1418          				// ---- LED Indication ----
   1419          				//
   1420          				if (light_timer) {
   1421          					light_timer--;
   1422          					//
   1423          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1424          						RED_SET();
   1425          						YEL_CLR();
   1426          					}else
   1427          					//
   1428          					if (DeviceMode == MODE_CALIBR) {
   1429          						RED_SET();
   1430          						YEL_SET();
   1431          					}
   1432          				}else{
   1433          					//
   1434          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_CALIBR) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1435                                                          RED_CLR();
   1436          						YEL_CLR();
   1437          					}
   1438          				}
   1439          				//	
   1440          				if ((DeviceMode == MODE_FAULT) || (DeviceMode == MODE_TEST)) {
   1441          					//
   1442          					// LED management
   1443          					//
   1444          					if (light_sync >= 3) {
   1445          						light_sync = 0;
   1446          						led_sh = 0x80000000;
   1447          						//
   1448          						led_timer = 300;	// 3 sec period
   1449          					}
   1450          					
   1451          					if (led_timer) {
   1452          						led_timer--;
   1453          					}else{
   1454          						led_timer = 300;	// 3 sec period
   1455          						led_sh = 0x80000000;
   1456          						//
   1457          						light_sync = 0;
   1458          					}
   1459          					//
   1460          					if (++led_clk >= 4) {		// T = 30 ms
   1461          						led_clk = 0;
   1462          						//
   1463          						if (led_r & led_sh) {
   1464          							RED_SET();
   1465          //							CH_IN_SET();
   1466          						}else{
   1467          							RED_CLR();
   1468          //							CH_IN_CLR();
   1469          						}
   1470          						//
   1471          						if (led_y & led_sh) {
   1472          							YEL_SET(); 
   1473          						}else{
   1474          							YEL_CLR();
   1475          						}
   1476          						//
   1477          						if (DeviceMode == MODE_TEST) {
   1478          							YEL_SET(); 
   1479          						}
   1480          						//
   1481          						led_sh >>= 1;
   1482          					}
   1483          				}
   1484          			} // End indication
   1485          
   1486          // Added for DL3
   1487                                  if(DeviceMode == MODE_FIRE){
   1488                                    fStartPulse = 0;
   1489                                  }
   1490                                  else
   1491                                    if (strob_pulse_timer == 0) {
   1492                                      fStartPulse = 1;                        
   1493                                      strob_pulse_timer = 120;
   1494                                    }
   1495                                    else{
   1496                                      strob_pulse_timer--;
   1497                                    }
   1498          
   1499          //DL3 PWM 
   1500                                    if(fPWMEnabled){
   1501                                            Timer_A0_StartPWM(PWM_period);
   1502                                          }
   1503          //end DL3 PWM      
   1504          //end  Added for DL3
   1505          
   1506          			//
   1507          			if (flash_period_timer) {
   1508          				flash_period_timer--;
   1509          				if (flash_period_timer == 0) {
   1510          					flash_period_timer = 120;	// Flash after 1.2 sec
   1511          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)){
   1512          						light_timer = 1;				// Value - the light power
   1513          					}else
   1514          					if (DeviceMode == MODE_CALIBR) {
   1515          						light_timer = 7;				// Value - the light power
   1516          					}
   1517          				}
   1518          			}
   1519                                  
   1520          		} // if (fTimerA1_On 10 ms)
   1521          		
   1522          //-------------------------------------------------------------------------------
   1523          // End of samples of ADC Event
   1524          		if (fEndOfSamples) {	// End of samples of ADC Event
   1525          			fEndOfSamples = 0;
   1526          		
   1527          			//VREF_Off();						// Vref Disable
   1528          			ADC10CTL0 &= ~ENC;
   1529          			while (ADC10CTL1 & BUSY);           // Wait if ADC10 core is active 
   1530          			ADC10CTL0 &= ~REFON;
   1531          			
   1532          			AMP_PWR_OFF();						// AMP Power Supply Disable
   1533          			//AMP_Off_Timer = CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;	//CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;
   1534          			//
   1535          
   1536          			BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 8 MГц
   1537          			DCOCTL =  CALDCO_8MHZ;
   1538          			//
   1539          			TA1CCR0  = 0xFFFF - 1;   			// ~ Compensation of frequence increase
   1540          			//
   1541          			DelayUs(1);
   1542          			//
   1543          			if (fSendingGraph) {
   1544          				loc_buf[0] = Q_SEND_GRAPH1;
   1545          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1546          				SoftUART_TxString(loc_buf, 2);
   1547          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1548          
   1549          
   1550          			}
   1551          			//
   1552          			if((DeviceMode == MODE_TEST) ||(DeviceMode == MODE_FAULT)){
   1553                	fPWMEnabled = 1;  
   1554                  Timer_A0_StartPWM(PWM_period);
   1555                }
   1556          /*
   1557          			else{
   1558                	fPWMEnabled = 0;  
   1559          			}
   1560          */			
   1561          			if (start_timer || CalibrFault.byte || DeviceFault.fFaultDrift) {
   1562          				goto label_light;
   1563          			}         
   1564          			
   1565          			quality = SignalAnalysis();
   1566          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1567          			DCOCTL =  CALDCO_1MHZ;
   1568          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1569          			DelayUs(1);
   1570                                  
   1571          			//
   1572          			if (DeviceMode == MODE_CALIBR) {
   1573          				//
   1574          				// -------- КАЛИБРОВКА ---------
   1575          				//
   1576          				n_counter++;
   1577          				summa += delta;
   1578          				
   1579          				if (n_counter >= 2) {
   1580          					delta = summa / n_counter;
   1581          		
   1582          					n_counter = 0;
   1583          					summa = 0;
   1584          					//
   1585          					s_array[calibr_stage] = delta;
   1586          					q_array[calibr_stage] = quality;
   1587          					//
   1588          					if (++calibr_stage >= CALIBR_STAGES) {
   1589          						// End of calibration
   1590          						//
   1591          						CalibrationResultAnalise();
   1592          						if (CalibrFault.byte) {
   1593          							DeviceMode = MODE_FAULT;
   1594          						}
   1595          						//
   1596          						goto label_light;
   1597          					}
   1598          					//
   1599          					//	Set new	 Amp_No	Gain  Reference
   1600          					amp_no = calibr_sequence[calibr_stage][0];
   1601          					gain = calibr_sequence[calibr_stage][1];
   1602          					reference = calibr_sequence[calibr_stage][2];
   1603          					//
   1604          					AMP_SetGain(gain);
   1605          					//
   1606          				}
   1607          			}else
   1608          			
   1609          			// Дежурный режим
   1610          			//
   1611          			if (quality == 2) {	
   1612          				// Very high signal
   1613          				if (++QualityFaultCounter > 10) {
   1614          					CalibrFault.fCalibr_Hi = 1;
   1615          					QualityFaultCounter = 0;
   1616          				}
   1617          				//
   1618          				goto label_light;
   1619          			}else{
   1620          				QualityFaultCounter = 0;
   1621          			}
   1622          			
   1623          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && fault_chain_timer) {
   1624          				// Обрабатывается полное перекрытие
   1625          				if (delta > getZeroLevel()) {
   1626          					fault_chain_timer = 0;
   1627          					fault_chain_ind = 0;
   1628          					DeviceFault.fSignal_Low = 0;
   1629          				}
   1630          			}
   1631          			
   1632          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && (fault_chain_timer == 0)) {
   1633          				if ((delta >= CONFIG->limit_fire) && (delta <= SYGNAL_MAX_VALUE)) {
   1634          					// Reset all counters
   1635          					fire_level_counter = 0;
   1636          					hi_signal_counter = 0;
   1637          					zero_timer = 0;
   1638          				}
   1639          								
   1640          				if (delta <= getZeroLevel()) {
   1641          					if (zero_timer == 0) {	
   1642          						zero_timer = 1;
   1643          					}else
   1644          					if (zero_timer > 1000) {	// 10 sec
   1645          						// Полное перекрытие 
   1646          						fault_chain_ind = 0;
   1647          						DeviceMode = fault_sequence[fault_chain_ind++];
   1648          						fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1649          						DeviceFault.fSignal_Low = 1;
   1650          						zero_timer = 0;
   1651          						//
   1652          						NFAULT_CLR();
   1653          
   1654          						//
   1655          					}
   1656          				}else{
   1657          					zero_timer = 0;
   1658          					//
   1659          					if (delta < CONFIG->limit_prefire) {
   1660          						DeviceMode = MODE_PREPREFIRE;
   1661          					}
   1662          					
   1663          					if (DeviceMode == MODE_PREPREFIRE) {
   1664          						if (delta > CONFIG->limit_prefire) {
   1665          							DeviceMode = MODE_NORM;
   1666          						}
   1667          					}
   1668          					
   1669          					if (delta < CONFIG->limit_fire) {
   1670          						fire_level_counter = 5;
   1671          						DeviceMode = MODE_PREFIRE;
   1672          					}
   1673          					
   1674          					// Hi signal management
   1675          					if (delta > SYGNAL_MAX_VALUE) {
   1676          						// Very high signal
   1677          						hi_signal_counter++;
   1678          						if (hi_signal_counter >= 10) {
   1679          							//DeviceMode = MODE_FAULT;
   1680          							CalibrFault.fCalibr_Hi = 1;
   1681          							hi_signal_counter = 0;
   1682          						}
   1683          					}
   1684          				}
   1685          			}else
   1686          			if (DeviceMode == MODE_PREFIRE) {
   1687          				//
   1688          				// Защита от плавного изменения уровня сигнала
   1689          				if ((delta == 0) && (delta_last > 0)) {
   1690          					fire_level_counter = 10;
   1691          				}
   1692          				//	
   1693          				if ((delta <= getZeroLevel()) && (fire_level_counter == 5)) {
   1694          					if (zero_timer == 0) {	
   1695          						zero_timer = 1;
   1696          						DeviceMode = MODE_NORM;
   1697          					}
   1698          				}else
   1699          				if (delta < CONFIG->limit_fire) {
   1700          					if (--fire_level_counter == 0) {
   1701          						DeviceMode = MODE_FIRE;
   1702          						FIRE_SET();
   1703          						RED_SET();
   1704          						YEL_CLR();
   1705          						DeviceFault.byte = 0;
   1706          					}
   1707          				}else{
   1708          					DeviceMode = MODE_NORM;
   1709          				}
   1710          				//
   1711          				delta_last = delta;
   1712          			}
   1713          			//
   1714          			if (CONFIG->config_reg.fDrift) {
   1715          				// if JP1 state is open
   1716          				if ((DeviceMode == MODE_NORM) && delta) {
   1717          					// Long Term Drift Adjustment
   1718          					DriftSumma += delta;
   1719          					DriftCounter++;
   1720          					if (DriftCounter >= DRIFT_SAMPLES_MAX) {
   1721          						DriftLevel = DriftSumma / DriftCounter;
   1722          						//
   1723          						if ((u16)DriftLevel < CONFIG->limit_drift) {
   1724          							//
   1725          							DeviceFault.fFaultDrift = 1;
   1726          							SetFaultMode();
   1727          							//
   1728          							SetLevels(CONFIG->limit_drift);
   1729          						}else{
   1730          							SetLevels((u16)DriftLevel);
   1731          						}
   1732          						//	
   1733          						ClearDriftVar();
   1734          						//
   1735          					}
   1736          				}
   1737          			}
   1738          			//			
   1739          			//
   1740          label_light:			
   1741          			//
   1742          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1743          			DCOCTL =  CALDCO_1MHZ;
   1744          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1745          			//
   1746          			DelayUs(1);
   1747          			//
   1748          
   1749                                  if (fSendingGraph) {
   1750          //DL3
   1751          
   1752          
   1753          				BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 8 MГц
   1754          				DCOCTL =  CALDCO_8MHZ;
   1755          				TA1CCR0  = 0xFFFF - 1;   				// ~ Compensation of frequence increase
   1756          				//
   1757          				//
   1758          				for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
   1759          					signal_array[i] += 350;
   1760          				}
   1761          				
   1762          				loc_buf[0] = Q_SEND_GRAPH2;
   1763          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1764          				SoftUART_TxString(loc_buf, 2);
   1765          				//
   1766          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1767          				
   1768          				SoftUART_TxString((u8*)&delta, 2);
   1769          				
   1770          				fSendingGraph = 0;
   1771          				//
   1772          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1773          				DCOCTL =  CALDCO_1MHZ;
   1774          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1775          				//
   1776          
   1777          //end DL3
   1778          			}
   1779          			//
   1780          			//
   1781          			// Indication
   1782          			//
   1783          			if (DeviceMode == MODE_NORM) {
   1784          				light_timer = 1;				// Value - the light power
   1785          				flash_period_timer = 120;		// Flash after 1.2 sec
   1786          //				flash_period_timer = 200;		// Flash after 2 sec
   1787          			}
   1788          			//
   1789          			if ((DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1790          				light_timer = 4;				// Value - the light power
   1791          				flash_period_timer = 120;		// Flash after 1.2 sec
   1792          //				flash_period_timer = 60;		// Flash after 1.2 sec
   1793          			}
   1794          			//
   1795          			if (DeviceMode == MODE_CALIBR) {
   1796          				light_timer = 7;				// Value - the light power
   1797          				flash_period_timer = 120;		// Flash after 1.2 sec
   1798          			}
   1799          			//
   1800          			if (DeviceMode == MODE_TEST) {
   1801          				// Indication sygnal level
   1802          				LedTestValueManager();			
   1803          				//
   1804          			}
   1805          			//
   1806          			light_sync++;
   1807          			led_timer = 400;	//4 sec
   1808          //			STROB_IE_Enable();
   1809          		}
   1810          		
   1811          //-------------------------------------------------------------------------------
   1812          // Strobe StartPulse Event		
   1813          		if (fStartPulse) {			// Start pulse was received
   1814          			fStartPulse = 0;
   1815          	
   1816          
   1817          			//
   1818          			AMP_PWR_ON();						// AMP Power Supply Enable
   1819          			// Vref Enable
   1820          			if (DeviceMode == MODE_CALIBR) {
   1821          				ADC_MeasureInit(amp_no, reference);
   1822          			}else{
   1823          				ADC_MeasureInit(CONFIG->AMP_No, reference);
   1824          			}
   1825          			
   1826          			_BIC_SR(GIE);    			// Запрещаем прерывания
   1827          
   1828          //DL3                        Timer_A0_SetDelay(2250);
   1829          			Timer_A0_StopPWM();
   1830                Timer_A0_SetDelay(1500);
   1831          //                        
   1832          			_BIS_SR(GIE);    			// Разрешаем прерывания
   1833          			//
   1834          			BCSCTL1 = CALBC1_8MHZ; 		// Используем частоту 8 MГц
   1835          			DCOCTL =  CALDCO_8MHZ;
   1836          			//
   1837          			TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1838          			//
   1839          			// For define the presence of strob pulses
   1840          //DL3			strob_pulse_timer = 0;
   1841                                  
   1842          			DeviceFault.fStrobNone = 0;
   1843          			//
   1844          			fault_phase = 0;
   1845          			fault_timer = 0;
   1846          		}
   1847          		
   1848          
   1849          //-------------------------------------------------------------------------------
   1850          // KEY DOWN event		
   1851          		if (fButtonDownOn) {									// Нажата кнопка
   1852          			fButtonDownOn = 0;
   1853          			//...
   1854          			timerKeyDown = 1;
   1855          			//
   1856          		} // if (fButtonDownOn)
   1857          		
   1858          //-------------------------------------------------------------------------------
   1859          // KEY UP event
   1860          		if (fButtonUpOn) {			// Отжата кнопка
   1861          			fButtonUpOn = 0;
   1862          
   1863          			if ((timerKeyDown > 4) && (timerKeyDown < 150))  {	// < 1.5 sec
   1864          				// The short pressure on the button
   1865          				if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)|| (DeviceMode == MODE_FAULT)) {
   1866          //DL3
   1867          					prevDeviceMode = DeviceMode;			//save current mode to be restored after test mode
   1868          					DeviceMode = MODE_TEST;
   1869          					prevDeviceFault = DeviceFault;
   1870          					DeviceFault.byte = 0;	// Reset all faults
   1871          
   1872          //DL3                                   FIRE_SET();				// Set fire mode current consumption
   1873          					NFAULT_SET();
   1874          //DL3 
   1875          					RED_CLR();
   1876          					YEL_SET();
   1877          					timerMain = 12000;		// 120 sec
   1878          					led_sh = 0;
   1879          					led_timer = 0;			// Устраняем задержку оптической индикации
   1880          					led_clk = 0xFF;
   1881                                                  
   1882                                                  fPWMEnabled = 1;
   1883          				}else
   1884          				//	
   1885          				if (DeviceMode == MODE_TEST) {
   1886          					DeviceMode = prevDeviceMode;
   1887          					DeviceFault = prevDeviceFault;
   1888          /*DL3						
   1889          					DeviceMode = MODE_NORM;
   1890          					DeviceFault.byte = 0;	// Reset all faults
   1891          
   1892          */
   1893          					led_timer = 0;
   1894          					RED_CLR();
   1895          					YEL_CLR();
   1896          //
   1897          					NFAULT_SET();
   1898          //DL3 
   1899          				}else
   1900          				//
   1901          				if (DeviceMode == MODE_FIRE) {
   1902          					DeviceMode = MODE_NORM;
   1903          					DeviceFault.byte = 0;	// Reset all faults
   1904          					RED_CLR();
   1905          					YEL_CLR();
   1906          
   1907          //DL3 
   1908          					FIRE_CLR();				// Disable Fire Output
   1909                                                  NFAULT_SET();
   1910          //DL3 
   1911          					led_r = 0;
   1912          					led_y = 0;
   1913          				}
   1914          			}
   1915          			//
   1916          			timerKeyDown = 0;
   1917          		} // if (fButtonUpOn) {
   1918          
   1919          		
   1920          //-------------------------------------------------------------------------------
   1921          // Soft UART Rx Hundler
   1922          		if (fRxLineDownOn) {
   1923          
   1924          			uart_rx_ind = 0;
   1925          // DL3
   1926          			//
   1927          label_rx_continue:
   1928          			fRxLineDownOn = 0;
   1929          			//
   1930          			DelayUs_8MHz(25);		// Delay to center of pulse
   1931          			//
   1932          			CH_IN_SET();
   1933          			CH_IN_CLR();
   1934          			//
   1935          			if ((INTER_BIT & INTER_IN) == 0) {
   1936          				SoftUART_SetReceiveByte();
   1937          				
   1938          			}else{
   1939          				//
   1940          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1941          				DCOCTL =  CALDCO_1MHZ;
   1942          				//
   1943          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	                // Period T(us) * F(MHz)
   1944          				//
   1945          				continue;		                                // False pulse
   1946          			}
   1947          			sh = 0x01;
   1948          			byte = 0;
   1949          			while (sh) {
   1950          				if (fTimerA_On) {
   1951          					fTimerA_On = 0;
   1952          					//
   1953          					//CH_IN_SET();
   1954          					//CH_IN_CLR();
   1955          					//
   1956          					if (INTER_BIT & INTER_IN) {
   1957          						byte |= sh;
   1958          					}
   1959          					sh <<= 1;
   1960          				}
   1961          			}
   1962          			// Receive byte
   1963          			SoftUART_ResetReceiveByte();
   1964          			//
   1965          			if (uart_rx_ind == 0) {
   1966          				// Begin of packet
   1967          				len = packet_len_table[byte];
   1968          				if (len > UART_BUF_LEN) {
   1969          					len = UART_BUF_LEN;
   1970          				}
   1971          			}
   1972          				
   1973          			*(uart_rx_buf+uart_rx_ind++) = byte;
   1974          			if (uart_rx_ind >= len) {
   1975          				// Parse of packet
   1976          				//...
   1977          				SoftUART_RxParse();
   1978          				INTER_IFG &= ~INTER_BIT;    				// Обнуляем флаг прерывания
   1979          				fRxLineDownOn = 0;
   1980          			}else{
   1981          				//			
   1982          				uart_timer = 4;								// 200 ms timeout to next byte
   1983          				while (1) {
   1984          					//__bis_SR_register(LPM3_bits + GIE);     // Enter LPM3
   1985          					//
   1986          					while ((fRxLineDownOn || fTimer50msOn) == 0) {}
   1987          					//
   1988          					if (fRxLineDownOn) {
   1989          						goto label_rx_continue;
   1990          					}
   1991          					if (fTimer50msOn) {						// Получен следующий 50мс интервал
   1992          						fTimer50msOn = 0;
   1993          						//
   1994          						if (uart_timer) {
   1995          							uart_timer--;
   1996          						}else{
   1997          							// End of Rx timeout
   1998          							//...
   1999          							INTER_IFG &= ~INTER_BIT;    	// Обнуляем флаг прерывания
   2000          							fRxLineDownOn = 0;
   2001          							break;
   2002          						}
   2003          					}
   2004          				}
   2005          			}
   2006          			//
   2007          			//
   2008          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   2009          			DCOCTL =  CALDCO_1MHZ;
   2010          			//
   2011          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   2012          			//
   2013          
   2014                             //
   2015          		} // Soft UART Rx Hundler
   2016          	} // while(1)
   2017          }
   2018          
   2019          
   2020          
   2021          
   2022          //--------------------------------------------------------------------------------
   2023          // Function		: __interrupt void watchdog_timer (void)
   2024          // Parameters	: None
   2025          // Return		: None
   2026          // Description	: WDT Interrupt routine
   2027          //--------------------------------------------------------------------------------
   2028          #pragma vector=WDT_VECTOR
   2029          __interrupt void watchdog_timer (void) {
   2030          	
   2031          	if (fTimer50msOn) {
   2032          		if (++Timer50msCounter == 0) {		// > ~ 12sec
   2033          //			WDTCTL = WDTCTL;				// Hardware RESET
   2034          		}
   2035          	}
   2036          	fTimer50msOn = 1;
   2037          	
   2038          //	__bic_SR_register_on_exit(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
   2039                  LPM3_EXIT;
   2040          }
   2041          
   2042          
   2043          
   2044          //--------------------------------------------------------------------------------
   2045          // Function		: __interrupt void CCR0_ISR(void)
   2046          // Parameters	: None
   2047          // Return		: None
   2048          // Description	: TIMER0 Interrupt routine
   2049          //--------------------------------------------------------------------------------
   2050          #pragma vector = TIMER0_A0_VECTOR
   2051          __interrupt void CCR0_ISR(void) {
   2052                    fTimerA_On = 1;
   2053          	
   2054          } // CCR0_ISR
   2055          
   2056          #pragma vector = TIMER0_A1_VECTOR
   2057          __interrupt void CCR_ISR(void) {
   2058                  TEST_OUT_SET();
   2059          } // CCR0_ISR
   2060          
   2061          
   2062          //--------------------------------------------------------------------------------
   2063          // Function		: __interrupt void Timer_A1_ISR (void)
   2064          // Parameters	: None
   2065          // Return		: None
   2066          // Description	: TIMER1 Interrupt routine
   2067          //--------------------------------------------------------------------------------
   2068          #pragma vector=TIMER1_A0_VECTOR
   2069          __interrupt void Timer_A1_ISR (void)  {
   2070          	
   2071          	fTimerA1_On = 1;
   2072          
   2073          	//__bic_SR_register_on_exit(LPM0_bits);                   // Clear LPM3 bits from 0(SR)
   2074          } 
   2075          
   2076          
   2077          
   2078          //--------------------------------------------------------------------------------
   2079          // Function		: void Led_Flash(u16 duration)
   2080          // Parameters	: duration - duration Red LED flash in ms
   2081          // Return		: None
   2082          // Description	: Flashing red LED
   2083          //--------------------------------------------------------------------------------
   2084          void Led_Flash(u16 duration) {
   2085                  IRED_SET();
   2086                  DelayUs(100);
   2087          	IRED_CLR();
   2088                  
   2089                  RED_SET();
   2090                  YEL_SET();
   2091          	DelayMs(duration);
   2092                  RED_CLR();
   2093                  YEL_CLR();
   2094          }
   2095          
   2096          //--------------------------------------------------------------------------------
   2097          // Function		: void VREF_On(void)
   2098          // Parameters	: None 
   2099          // Return		: None
   2100          // Description	: Enable VREF
   2101          //--------------------------------------------------------------------------------
   2102          void VREF_On(void) {
   2103          
   2104          	ADC10CTL0 = REFOUT + REFON + SREF_1 + MSC + ADC10ON;
   2105          	ADC10AE0 |= 0x10;                         // P1.4 ADC option select (VRef Out)
   2106          
   2107          }
   2108          
   2109          
   2110          
   2111          //--------------------------------------------------------------------------------
   2112          // Function		: void VREF_Off(void)
   2113          // Parameters	: None
   2114          // Return		: None
   2115          // Description	: Disable VREF
   2116          //--------------------------------------------------------------------------------
   2117          void VREF_Off(void) {
   2118          
   2119          	ADC10CTL0 = 0;							// Disable ADC & +VREF
   2120          	ADC10CTL0 = 0;							//
   2121          }
   2122          
   2123          
   2124          
   2125          //--------------------------------------------------------------------------------
   2126          // Function		: void ADC10_ISR(void)
   2127          // Parameters	: None
   2128          // Return		: None
   2129          // Description	: ADC10 interrupt service routine
   2130          //--------------------------------------------------------------------------------
   2131          #pragma vector=ADC10_VECTOR
   2132          __interrupt void ADC10_ISR(void) {
   2133          
   2134          	//ADC10AE0 &= ~0x0F;                      // Save only VRef Out
   2135          	
   2136          	adc_process = 0;
   2137          	
   2138          	fEndOfSamples = 1;
   2139                  
   2140          	//__bic_SR_register_on_exit(CPUOFF);      // Clear CPUOFF bit from 0(SR)
   2141          	
   2142          }
   2143          
   2144          
   2145          
   2146          //--------------------------------------------------------------------------------
   2147          // Function		: u16 AverageData(u16 * data_ptr, u8 len)
   2148          // Parameters	: data_ptr - data array pointer, len - length of data array
   2149          // Return		: Average value of data
   2150          // Description	: Fuction calculate the average value of data array
   2151          //--------------------------------------------------------------------------------
   2152          u16 AverageData(u16 * data_ptr, u8 len) {
   2153          	u16 summa = 0;
   2154          	u8  i = len;
   2155          	while (i--) {
   2156          		summa += *data_ptr++;
   2157          	}
   2158          	//
   2159          	return (summa/len);
   2160          }
   2161          
   2162          
   2163          //--------------------------------------------------------------------------------
   2164          // Function		: void DeviceDiagnostics(void)
   2165          // Parameters	: None
   2166          // Return		: None
   2167          // Description	: Procedure of the diagnostics device
   2168          //--------------------------------------------------------------------------------
   2169          void DeviceDiagnostics(void) {
   2170          	//
   2171          	DelayMs(100);
   2172          	//
   2173          	//
   2174          		
   2175          #if (CRC_ENABLE == 1)
   2176          	// Check CS of Memory
   2177          	DeviceFault.fFaultCRC = 0;
   2178          	if (GetPropertiesCS() != CONFIG->CS) {
   2179          		DeviceFault.fFaultCRC = 1;
   2180          	}
   2181          #endif
   2182          }
   2183          
   2184          //--------------------------------------------------------------------------------
   2185          // Function		: u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count)
   2186          // Parameters	: refout = 0 or REFOUT, vref = REF1_5V , count - кол-во измерений 
   2187          // Return		: None
   2188          // Description	: Measurement of the current temperature of MCU
   2189          //--------------------------------------------------------------------------------
   2190          #pragma optimize=none
   2191          u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count) {
   2192          	u16 res;
   2193          
   2194          	while(adc_process) {}
   2195          	
   2196          	BUT_IE &= ~BUT_BIT;
   2197          	BUT_REN &= ~BUT_BIT; 		// PULL disable
   2198          	
   2199          	ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC  + ADC10ON + ADC10IE;	// Sample&hold = 8 x ADC10CLKs
   2200          	
   2201          	DelayUs(50);	
   2202          	//
   2203          	ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ch;	// ADC_BUT;     // 
   2204          	//
   2205          	DelayUs(200);							// Delay to allow Ref to settle
   2206          
   2207          	ADC10DTC1 = count;						// count of conversions
   2208          	ADC10AE0 = ADC_AE_BUT;                 // A3 & A7 ADC option select
   2209          	//
   2210          	ADC10SA = (u16) &buf[0];          		// Data buffer start
   2211          	
   2212          	fEndOfSamples = 0;
   2213          	ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
   2214          		
   2215          	__bis_SR_register(CPUOFF + GIE);        // LPM0, ADC10_ISR will force exit
   2216          	
   2217          	while (fEndOfSamples == 0){};
   2218          	fEndOfSamples = 0;
   2219          
   2220          	res = AverageData(buf, count);	
   2221          
   2222          	ADC10AE0 = ADC_AE;          // A3 & A7 ADC option select
   2223          	
   2224          	BUT_IFG &= ~BUT_BIT;    	// Обнуляем флаг прерывания
   2225          	BUT_IE |= BUT_BIT;
   2226          	BUT_REN |= BUT_BIT; 		// PULL enable
   2227          	
   2228          	return res;
   2229          }
   2230          
   2231          
   2232          //--------------------------------------------------------------------------------
   2233          // Function		: void u8 JP1_Define(void)
   2234          // Parameters	: None
   2235          // Return		: 0 - JP1 Open, 1 - JP1 Close
   2236          // Description	: Definition of JP1 state
   2237          //--------------------------------------------------------------------------------
   2238          void JP1_Define(void) {
   2239          	u16 buf[4];
   2240          	u16 temp;
   2241          	
   2242          	temp = ADC_Measure_Simple(ADC_BUT, buf, 4);
   2243          	
   2244          	if (temp > 600) return; 
   2245          	if (temp > 100) {
   2246          		jp1_state = 0;		// JP1 is Open 
   2247          	}else{
   2248          		jp1_state = 1;		// JP1 is Close
   2249          	}	
   2250          	//
   2251          	return;	
   2252          }
   2253          
   2254          
   2255          // End of main.c

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   ADC10_ISR
      4   ADC_MeasureInit
        4   -> DelayUs
      2   ADC_MeasureStart
     10   ADC_Measure_Simple
       10   -> AverageData
       10   -> DelayUs
       10 ?Epilogue4
      2   ADC_SetParam
      2   AMP_Gain_Init
        0   -> AMP_SetGain
      2   AbsValue
      4   AverageData
        4 ?DivMod16u
      4   CCR0_ISR
      4   CCR_ISR
     22   CalibrationResultAnalise
       22   -> AMP_SetGain
       22   -> SetLevelsFromCalibr
       22   -> SetLimitCompens
       22   -> StoragePropertyByte
       22   -> StoragePropertyWord
       14 ?Epilogue6
      2   ClearDriftVar
      2   DeviceDiagnostics
        2   -> DelayMs
        2   -> GetPropertiesCS
      2   DeviceStart
        0   -> ClearDriftVar
        2   -> VLO_TimerCalibr
      2   FaultSignalManager
     10   JP1_Define
       10   -> ADC_Measure_Simple
      2   LedTestValueManager
      4   Led_Flash
        4   -> DelayMs
        4   -> DelayUs
      2   SetFaultMode
      6   SetLevels
        6   -> ClearDriftVar
        6   -> SavePropertyCS
        6   -> StoragePropertyWord
        6 ?DivMod16s
        6 ?DivMod16u
      6   SetLevelsFromCalibr
        6   -> ClearDriftVar
        6   -> SavePropertyCS
        6   -> StoragePropertyWord
        6 ?DivMod16u
      2   SetLimitCompens
        0   -> ClearDriftVar
        2   -> SavePropertyCS
        2   -> StoragePropertyWord
     28   SignalAnalysis
       28   -> AverageData
       28   -> fir_filter
       28 ?ClearMemoryBytes
       28 ?DivMod16s
       14 ?Epilogue6
      2   TimerA1_DelayUs
      2   Timer_A0_Off
      2   Timer_A0_SetDelay
      2   Timer_A0_SetPWMPulse
      4   Timer_A0_StartPWM
        4 ?DivMod16u
      2   Timer_A0_StopPWM
      4   Timer_A1_ISR
      2   Timer_A1_Init
      2   VLO_GetPeriod
      2   VLO_TimerCalibr
        2   -> SavePropertyCS
        2   -> StoragePropertyWord
      2   VREF_Off
      2   VREF_On
      8   fir_filter
        8 ?DivMod32s
        8 ?Epilogue3
        8 ?Mul16to32s
        8 ?ShiftRight32s_9
      2   getTimerValue
      2   getZeroLevel
        0 ?DivMod16u
     12   main
       12   -> ADC_MeasureInit
       12   -> ADC_MeasureStart
       12   -> ADC_SetParam
       12   -> AMP_SetGain
       12   -> CalibrationResultAnalise
       12   -> ClearDriftVar
       12   -> DelayMs
       12   -> DelayUs
       12   -> DelayUs_8MHz
       12   -> DeviceStart
       12   -> FaultSignalManager
       12   -> GPIO_Init
       12   -> JP1_Define
       12   -> LedTestValueManager
       12   -> Led_Flash
       12   -> SetFaultMode
       12   -> SetLevels
       12   -> SignalAnalysis
       12   -> SoftUART_ResetReceiveByte
       12   -> SoftUART_RxParse
       12   -> SoftUART_SetReceiveByte
       12   -> SoftUART_TxString
       12   -> Timer_A0_Off
       12   -> Timer_A0_SetDelay
       12   -> Timer_A0_StartPWM
       12   -> Timer_A0_StopPWM
       12   -> Timer_A1_Init
       12   -> getTimerValue
       12   -> getZeroLevel
       12 ?DivMod16u
       12 ?DivMod32u
      4   watchdog_timer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       7  ?<Constant {0, 0, 0, 0, 0, 0, 0}>
       7  ?<Constant {0, 0, 0, 0, 0, 0, 0}>_1
       1  ?<Initializer for jp1_state>
       1  ADC10AE0
       2  ADC10CTL0
       2  ADC10CTL1
       1  ADC10DTC1
       2  ADC10SA
      10  ADC10_ISR
       2  ADC10_ISR::??INTVEC 10
      92  ADC_MeasureInit
      24  ADC_MeasureStart
     140  ADC_Measure_Simple
      36  ADC_SetParam
       8  AMP_Gain_Init
      14  AbsValue
      30  AverageData
       1  BCSCTL1
       1  BCSCTL3
       1  CALBC1_16MHZ
       1  CALBC1_1MHZ
       1  CALBC1_8MHZ
       1  CALDCO_16MHZ
       1  CALDCO_1MHZ
       1  CALDCO_8MHZ
       4  CCR0_ISR
       2  CCR0_ISR::??INTVEC 18
       2  CCR1_Value
       8  CCR_ISR
       2  CCR_ISR::??INTVEC 16
       1  CalibrFault
     420  CalibrationResultAnalise
      22  ClearDriftVar
       1  DCOCTL
      32  DeviceDiagnostics
       1  DeviceFault
       1  DeviceMode
      16  DeviceStart
       2  DriftCounter
       4  DriftLevel
       4  DriftSumma
      18  FIRCoef
     274  FaultSignalManager
       1  IE1
       1  IFG1
      36  JP1_Define
     132  LedTestValueManager
      54  Led_Flash
       1  P1IE
       1  P1IFG
       1  P1OUT
       1  P1REN
       1  P1SEL
       1  P2DIR
       1  P2IFG
       1  P2IN
       1  P2OUT
       2  PWM_period
      24  SetFaultMode
      94  SetLevels
     162  SetLevelsFromCalibr
      24  SetLimitCompens
     582  SignalAnalysis
       2  TA0CCR0
       2  TA0CCR1
       2  TA0CCTL0
       2  TA0CCTL1
       2  TA0CTL
       2  TA0R
       2  TA1CCR0
       2  TA1CCTL0
       2  TA1CTL
       2  TA1R
       1  Timer50msCounter
      40  TimerA1_DelayUs
      30  Timer_A0_Off
      42  Timer_A0_SetDelay
      22  Timer_A0_SetPWMPulse
      94  Timer_A0_StartPWM
      26  Timer_A0_StopPWM
       6  Timer_A1_ISR
       2  Timer_A1_ISR::??INTVEC 26
      28  Timer_A1_Init
      30  VLO_GetPeriod
      68  VLO_TimerCalibr
      10  VREF_Off
      14  VREF_On
       2  WDTCTL
      32  adc_data1
       1  adc_process
       1  amp_no
      18  calibr_sequence
       1  calibr_stage
       2  cfg_reg
       2  d1
       2  d2
       2  d3
       2  d4
       2  dark
       2  delta
       2  delta_last
       2  f
       1  fTimerA1_On
       1  fault_chain_ind
       2  fault_chain_timer
       1  fault_chamber_counter
       1  fault_phase
       8  fault_sequence
       2  fault_timer
     114  fir_filter
       2  flash_period_timer
       1  gain
      30  getTimerValue
      12  getZeroLevel
       2  hi_signal_counter
       1  jp1_state
       2  last_0_level
       2  last_level
       4  led_r
       4  led_sh
       4  led_y
       1  light_sync
       2  light_timer
    2420  main
       1  prevDeviceFault
       1  prevDeviceMode
       6  q_array
       1  reference
      12  s_array
     200  signal_array
       2  start_timer
       1  strob_fault_phase
       2  strob_pulse_timer
       2  timerKeyDown
       2  timerMain
      18  watchdog_timer
       2  watchdog_timer::??INTVEC 20
      36  x
       2  zero_timer

 
 5 242 bytes in segment CODE
    50 bytes in segment DATA16_AN
    58 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
   369 bytes in segment DATA16_Z
    10 bytes in segment INTVEC
     2 bytes in segment REGVAR_AN
 
 5 242 bytes of CODE     memory
    59 bytes of CONST    memory (+ 10 bytes shared)
   370 bytes of DATA     memory (+ 50 bytes shared)
     0 bytes of REGISTER memory (+  2 bytes shared)

Errors: none
Warnings: 7
