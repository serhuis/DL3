###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           08/Nov/2017  15:50:28
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\ARTON-DL3\soft\current\main.c
#    Command line  =  
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\main.c -lcN
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\List -o
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\Obj --no_unroll
#        --no_inline --no_tbaa --debug -D__MSP430G2553__ -e --double=32
#        --regvar_r4 --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\430\lib\dlib\dl430fn.h" -I ..\ -I .\ -Om
#    List file     =  
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\List\main.lst
#    Object file   =  
#        E:\_ARTON_PROJ\ARTON-DL3\soft\current\IAR\Debug\Obj\main.r43
#
###############################################################################

E:\_ARTON_PROJ\ARTON-DL3\soft\current\main.c
      1          /**********************************************************************************
      2           *
      3           *      ASD-10QR MAIN routine
      4           * 
      5           **********************************************************************************
      6           * FileName:        main.c
      7           * Version:			1.00
      8           *
      9           * Processor:       MSP430G2xxx
     10           * Complier:        IAR Workbench for MSP430 v4.50 or higher
     11           *                  
     12           * Company:         ARTON
     13           *
     14           * Software License Agreement
     15           *
     16           * The software supplied herewith by ARTON Incorporated
     17           * (the "Company") for its devices is intended and
     18           * supplied to you, the Company's customer, for use solely and
     19           * exclusively on ARTON Inc products. The
     20           * software is owned by the Company and/or its Author, and is
     21           * protected under applicable copyright laws. All rights are reserved.
     22           * Any use in violation of the foregoing restrictions may subject the
     23           * user to criminal sanctions under applicable laws, as well as to
     24           * civil liability for the breach of the terms and conditions of this
     25           * license.
     26           *
     27           * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
     28           * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
     29           * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
     30           * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
     31           * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
     32           * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
     33           *
     34           *
     35           * Author               Date      	Version	  		Comment
     36           *--------------------------------------------------------------------------------
     37           * Oleg Semeniuk	 16.01.2014    	1.00		Release for v1.00
     38           *
     39           *********************************************************************************/
     40          
     41          
     42          /*********************************************************************************/
     43          /*                                 INCLUDES                                      */
     44          /*********************************************************************************/
     45          
     46          
     47          #include <stdio.h>                    /* standard I/O .h-file                */
     48          #include <string.h>                   /* string and memory functions         */
     49          
     50          #include  "hardware.h"
     51          #include  "main.h"
     52          #include  "flash.h"
     53          #include  "type.h"
     54          #include  "delay.h"
     55          #include  "soft_uart.h"
     56          
     57          
     58          /*********************************************************************************/
     59          /*                                 VARIABLES                                     */
     60          /*********************************************************************************/
     61          
     62          __regvar __no_init tFlags 	f 	 @ __R4; 	// Set of state machine flags
     63          
     64          //
     65          u16		timerMain;					// Текущее значение главного таймера
     66          //u16		mainPeriodCounter;			// Counter of main time period
     67          u16 	timerKeyDown;				// Для отслеживания нажатия на кнопку TEST
     68          u16		adc_data1[ADC_CH_DATA_LEN];	// Array for ADC samples
     69          
     70          u8 		DeviceMode; 				// Mode of device
     71          u8 		prevDeviceMode; 				// Mode of device to be restored from after TEST mode
     72          
     73          tFault	DeviceFault = {0};			// Current Faults flags
     74          tFault	prevDeviceFault = {0};			// previous Faults flags to be restored from after TEST mode
     75          
     76          tCalibrFault CalibrFault = {0};		// Calibration Faults flags
     77          u16 	dark;						// Level of dark signal
     78          u16 	delta;						// Current level signal
     79          
     80          u16 	delta_last = 0;				// Prev sygnal of delta
     81          u16		zero_timer = 0;				// Zero level signal timer
     82          
     83          u8		fault_chamber_counter = 0;	// Counter of series chamber fault
     84          //u8  	FireMeasCount = 0;			// Количество замеров, превышающих порог Пожара
     85          
     86          // Variables for definition Long Term Drift
     87          u16  	DriftCounter = 0;
     88          u32 	DriftSumma = 0;
     89          u32 	DriftLevel;					// Current Long Term Drift Level
     90          	
     91          //u16 	FireLimit;					// Current Limit of Fire
     92          //u16 	PreFireLimit;				// Current Limit of PreFire
     93          	
     94          u16		CCR1_Value;					// CCR1 PWM duty cycle for sound generation
     95          u8 		Timer50msCounter = 0;		// Counter of 50ms ticks
     96          
     97          
     98          s16		signal_array[SIGNAL_ARRAY_LEN];
     99          
    100          volatile u32		led_r;
    101          volatile u32		led_y;
    102          volatile u32		led_sh = 0;
    103          
    104          u8 		fTimerA1_On = 0;
    105          
    106          
    107          #define CALIBR_STAGES		6
    108          u8 		calibr_stage;
    109          u16		s_array[CALIBR_STAGES];
    110          u8		q_array[CALIBR_STAGES];
    111          
    112          
    113          const u8 calibr_sequence[CALIBR_STAGES][3] = {
    114          //			 Amp_No	Gain  Reference
    115          			{  1,    0,     2 },
    116          			{  2,    0,     1 },
    117          			{  2,    1,     1 },
    118          			{  2,    2,     1 },
    119          			{  2,    3,     1 },
    120          			{  2,    3,     0 },
    121          };
    122          //
    123          
    124          const u8 fault_sequence[4 * 2] = {MODE_FAULT, 10, MODE_NORM, 10, MODE_FIRE, 0, 0};	// 0 = ~~
    125          
    126          u8  fault_chain_ind = 0;	// 	
    127          u16 fault_chain_timer = 0;
    128          
    129          s8	gain;
    130          u8	amp_no;
    131          u8	reference;
    132          tCfgReg	cfg_reg;
    133          
    134          u8	jp1_state = 1;			// 0 - JP1 Open, 1 - JP1 Close
    135          
    136          u8	adc_process = 0;		// ADC low level semafore
    137          
    138          u16	light_timer = 0;		// For led lighting
    139          u8	light_sync = 0;			// For led lighting syncronisation
    140          
    141          u16	strob_pulse_timer = 0;	// Таймер ожидания электрической синхронизации
    142          u8	strob_fault_phase = 0;	// Фаза неисправности электрической синхронизации 0 - отключение БИ, 1 - включение БИ
    143          
    144          u16	hi_signal_counter  = 0;	// Very Hight signal counter
    145          
    146          u16	fault_timer = 0;		// Fault signal timer
    147          u8  fault_phase  = 0;		// Phase of  fault signal: 1 - break of BI , 0 - enable of  BI	
    148          
    149          u16 start_timer = 0;		// Start timer of device
    150          
    151          u16 flash_period_timer;		// Flast period timer
    152          
    153          u16 PWM_period = 0;
    154          
    155          
    156          
    157          /*********************************************************************************/
    158          /*                                FUNCTIONS                                      */
    159          /*********************************************************************************/
    160          // --- Declarations ---
    161          void ADC_MeasureInit(u8 input_no, u8 refer);
    162          u8   SignalAnalysis(void);
    163          void ADC_MeasureStart(void);
    164          void AMP_Calibration(void);
    165          
    166          u16  AverageData(u16 * data_ptr, u8 len);
    167          u8   RX_PacketParser(void);
    168          void ADC_Measure(u16 ch, u16 refout, u8 count);
    169          
    170          void Timer_A1_Init(void);
    171          void Timer_A0_SetDelay(u16 period);
    172          void Timer_A0_Off(void);
    173          void JP1_Define(void);
    174          
    175          //--------------------------------------------------------------------------------
    176          // Function		: void ClearDriftVar(void)
    177          // Parameters	: None
    178          // Return		: None
    179          // Description	: Clear Long Term Drift variables
    180          //--------------------------------------------------------------------------------
    181          void ClearDriftVar(void) {
    182          	DriftCounter = 0;
    183          	DriftSumma = 0;
    184          	DriftLevel = 0;
    185          }
    186          
    187          
    188          
    189          //--------------------------------------------------------------------------------
    190          // Function		: void SetLimitCompens(void)
    191          // Parameters	: fire_level - fire level in increment
    192          // Return		: None
    193          // Description	: Setting limit compensation level
    194          //--------------------------------------------------------------------------------
    195          void SetLimitCompens(void) {
    196          	u16 norm = CONFIG->limit_norm;
    197          	//
    198          	StoragePropertyWord(eeLIMIT_LONG_DRIFT_OFFSET, norm / 2);
    199          	//
    200          #if (1 == CRC_ENABLE)
    201          	SavePropertyCS();
    202          #endif
    203          	//
    204          	ClearDriftVar();
    205          	//
    206          }
    207          
    208          
    209          
    210          //--------------------------------------------------------------------------------
    211          // Function		: void SetLevels(u16 norm)
    212          // Parameters	: norm - norm sygnal level 
    213          // Return		: None
    214          // Description	: Calculation and setting levels depending on background signal
    215          //--------------------------------------------------------------------------------
    216          void SetLevels(u16 norm) {
    217          	u16 temp;
    218          	u8  d;	
    219          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    220          	//
    221          	d = norm * 28 / 100;
    222          	//
    223          	temp = norm - d;		//
    224          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    225          	//
    226          	temp = norm - d * 3 / 4;		//
    227          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    228          	
    229          	//
    230          #if (1 == CRC_ENABLE)
    231          	SavePropertyCS();
    232          #endif
    233          	//
    234          	ClearDriftVar();
    235          	//
    236          }
    237          
    238          
    239          
    240          //--------------------------------------------------------------------------------
    241          // Function		: void SetLevels(u16 norm)
    242          // Parameters	: norm - norm sygnal level, nonlinearity_corr - correction 
    243          //				  nonlinearity in case of Hi signal (0 - none, 1 - low correction,
    244          //				  2 - hi correction)
    245          // Return		: None
    246          // Description	: Calculation and setting levels depending on background signal
    247          //--------------------------------------------------------------------------------
    248          void SetLevelsFromCalibr(u16 norm, u8 nonlinearity_corr) {
    249          	u16 temp;
    250          	u16  d;	
    251          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    252          	//
    253          	switch (nonlinearity_corr) {
    254          		case 0:
    255          			d = norm * 29 / 100;
    256          			break;
    257          		case 1:
    258          			d = norm * 23 / 100;
    259          
    260          			
    261          			break;
    262          		case 2:
    263          			d = norm * 18 / 100;
    264          			break;
    265          		default:
    266          			d = norm * 29 / 100;
    267          	}
    268          	//
    269          	temp = norm - d;		//
    270          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    271          	//
    272          	temp = norm - d * 3 / 4;		//
    273          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    274          	
    275          	//
    276          #if (1 == CRC_ENABLE)
    277          	SavePropertyCS();
    278          #endif
    279          	//
    280          	ClearDriftVar();
    281          	//
    282          }
    283          
    284          
    285          
    286          //--------------------------------------------------------------------------------
    287          // Function		: void DeviceStart(void)
    288          // Parameters	: None
    289          // Return		: None
    290          // Description	: Function executes initialization variable at start of device
    291          //--------------------------------------------------------------------------------
    292          void DeviceStart(void) {
    293          
    294          	DeviceFault.byte = 0;		// Reset faults flags
    295          	CalibrFault.byte = 0;		// Reset faults flags
    296          	//
    297          	ClearDriftVar();
    298          	
    299          #if (CRC_ENABLE == 1)
    300          	// Check CS of Memory
    301          	DeviceFault.fFaultCRC = 0;
    302          	if (GetPropertiesCS() != CONFIG->CS) {
    303          		DeviceFault.fFaultCRC = 1;
    304          	}
    305          #endif
    306          
    307          	
    308          }
    309          
    310          
    311          //--------------------------------------------------------------------------------
    312          // Function		: void DefineFireLimit(void)
    313          // Parameters	: None
    314          // Return		: None
    315          // Description	: Determination fire and prefire limits depending on long term drift
    316          //--------------------------------------------------------------------------------
    317          //#pragma optimize=none
    318          u16 getZeroLevel(void) {
    319          	u16 ret;
    320          
    321          //attenuation is more then 7dB (20%)
    322          	ret = CONFIG->limit_norm / 5;                   
    323          	return ret;
    324          }
    325          
    326          
    327          //--------------------------------------------------------------------------------
    328          // Function		: u16 getTimerValue(u16 period_sec)
    329          // Parameters	: time_sec : time in sec (0..655)
    330          // Return		: None
    331          // Description	: Getting time in system ticks
    332          //--------------------------------------------------------------------------------
    333          static u16 getTimerValue(u16 time_sec) {
    334          	u16 time = 100;
    335          	
    336          	if (time_sec > 655) return 0;
    337          	time *= time_sec;	
    338          	return time;
    339          }
    340          
    341          //--------------------------------------------------------------------------------
    342          // Function		: void VLO_TimerCalibr(void)
    343          // Parameters	: None
    344          // Return		: None
    345          // Description	: Calculation calibration value of VLO timer
    346          //--------------------------------------------------------------------------------
    347          void AMP_Gain_Init(void) {
    348          	
    349          	AMP_SetGain(CONFIG->Gain);
    350          	
    351          }
    352          
    353          #define ADC_AMP1	INCH_1		/* First AMP out */
    354          #define ADC_AMP2	INCH_0		/* Second AMP out */
    355          #define ADC_BUT		INCH_2		/* Tact button */
    356          #define ADC_AE		0x13		/* Analog (Input) Enable Control Register Value + VREF+*/
    357          #define ADC_AE_BUT	0x17		/* Analog (Input) Enable Control Register Value + Tact sw + VREF+*/
    358          
    359          #define ADC_FLUCTATION			20
    360          #define SIGNAL_0_LEVEL			512
    361          
    362          #define CORREL_LEVEL			120		/* Threshold level to correlations of the start signal */
    363          
    364          
    365          
    366          //--------------------------------------------------------------------------------
    367          // Function		: ADC_Measure(u8 input_no, u8 refer)
    368          // Parameters	: input_no - number AMP output (= 1 or 2), refer - reference voltage (=0 - 1.5V, =1 - 2.5V, =2 - 3.3V)
    369          // Return		: None
    370          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    371          //				   ~109 kS/s for 16 MHz 
    372          //--------------------------------------------------------------------------------
    373          void ADC_MeasureInit(u8 input_no, u8 refer) {
    374          	
    375          	ADC10CTL0 &= ~ENC;
    376          	while (ADC10CTL1 & BUSY);             	// Wait if ADC10 core is active 
    377          	//
    378          	switch ((Ref_Type)refer) {
    379          		case REF_1_5V:  
    380          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE;				// Sample&hold = 8 x ADC10CLKs
    381          			break;
    382          		case REF_2_5V:  
    383          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    384          			break;
    385          		case REF_3_3V:  
    386          			ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC + ADC10ON + ADC10IE  + REFOUT + REFON + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    387          			break;
    388          	default:
    389          		ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    390          
    391          	}
    392          	//
    393          	DelayUs(50);	
    394          	//
    395          	ADC10DTC1 = SIGNAL_ARRAY_LEN;	//ADC_SAMPLES_NUMBER;			// count of conversions
    396          	//
    397          	if (input_no == 1) {
    398          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP1;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 1
    399          	}else{
    400          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP2;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 2
    401          	}
    402          	
    403          	ADC10AE0 |= ADC_AE;                     // A0 & A1 ADC option select
    404          	//
    405          }
    406          
    407          
    408          //--------------------------------------------------------------------------------
    409          // Function		: ADC_Measure(u16 ch, u16 refout, u8 count)
    410          // Parameters	: ch - ADC channel, refout - 0 or REFOUT, count - кол-во измерений 
    411          // Return		: None
    412          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    413          //--------------------------------------------------------------------------------
    414          void ADC_MeasureStart(void) {
    415          	__disable_interrupt();		// Disable interrupt
    416          	
    417          	adc_process = 1;
    418          	
    419          	//ADC10SA = (u16) &signal_array[SIGNAL_ARRAY_LEN - ADC_SAMPLES_NUMBER];      	// Data buffer start - end of sygnal_array
    420          	ADC10SA = (u16) &signal_array[0];	// Data buffer start - end of sygnal_array
    421          	ADC10CTL0 |= ENC + ADC10SC;         // Sampling and conversion start
    422          	//
    423          
    424          	__enable_interrupt();                     // enable interrupts
    425          }
    426          
    427          u16 last_0_level;
    428          u16 last_level;
    429          
    430          //--------------------------------------------------------------------------------
    431          // Function		: void VLO_TimerCalibr(void)
    432          // Parameters	: None
    433          // Return		: 0 - no valid array, 1
    434          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    435          //--------------------------------------------------------------------------------
    436          u16 AbsValue(u16 x1, u16 x2) {
    437          	if (x1 >= x2) {
    438          		return (x1 - x2);
    439          	}else{
    440          		return (x2 - x1);
    441          	}
    442          }
    443          
    444          /**************************************************************
    445          WinFilter version 0.8
    446          http://www.winfilter.20m.com
    447          akundert@hotmail.com
    448          
    449          Filter type: Band Pass
    450          Filter model: Butterworth
    451          Filter order: 8
    452          Sampling Frequency: 109 KHz
    453          Fc1 and Fc2 Frequencies: 3.800000 KHz and 14.000000 KHz
    454          Coefficents Quantization: 8-bit
    455          
    456          Z domain Zeros
    457          z = -1.000000 + j 0.000000
    458          z = -1.000000 + j 0.000000
    459          z = -1.000000 + j 0.000000
    460          z = -1.000000 + j 0.000000
    461          z = -1.000000 + j 0.000000
    462          z = -1.000000 + j 0.000000
    463          z = -1.000000 + j 0.000000
    464          z = -1.000000 + j 0.000000
    465          z = 1.000000 + j 0.000000
    466          z = 1.000000 + j 0.000000
    467          z = 1.000000 + j 0.000000
    468          z = 1.000000 + j 0.000000
    469          z = 1.000000 + j 0.000000
    470          z = 1.000000 + j 0.000000
    471          z = 1.000000 + j 0.000000
    472          z = 1.000000 + j 0.000000
    473          
    474          Z domain Poles
    475          z = 0.644814 + j -0.260807
    476          z = 0.644814 + j 0.260807
    477          z = 0.756494 + j -0.196546
    478          z = 0.756494 + j 0.196546
    479          z = 0.587475 + j -0.386644
    480          z = 0.587475 + j 0.386644
    481          z = 0.840396 + j -0.195195
    482          z = 0.840396 + j 0.195195
    483          z = 0.588237 + j -0.523443
    484          z = 0.588237 + j 0.523443
    485          z = 0.901607 + j -0.202202
    486          z = 0.901607 + j 0.202202
    487          z = 0.951542 + j -0.212108
    488          z = 0.951542 + j 0.212108
    489          z = 0.642148 + j -0.658914
    490          z = 0.642148 + j 0.658914
    491          ***************************************************************/
    492          
    493          #define Ntap 18
    494          
    495          // !!! See division by DCgain below
    496          #define DCgain 512	
    497          
    498          //const s16 FIRCoef[Ntap] = { 
    499          const s8 FIRCoef[Ntap] = { 
    500                    -13,
    501                    -32,
    502                    -52,
    503                    -59,
    504                    -43,
    505                     -2,
    506                     50,
    507                     95,
    508                    113,
    509                     95,
    510                     50,
    511                     -2,
    512                    -43,
    513                    -59,
    514                    -52,
    515                    -32,
    516                    -13,
    517                     -3
    518          };
    519          
    520          
    521          static s16 	x[Ntap] = {0};	//, 512, 512, 512 }; 	//input samples
    522          
    523          s16 fir_filter(s16 sample) {
    524              s32	 		y = 0;      //output sample
    525              int 		i;
    526          	
    527              // Shift the old samples
    528          __disable_interrupt();
    529              for(i = Ntap-1; i > 0; i--) {
    530          		x[i] = x[i-1];
    531          	}
    532          	
    533              // Calculate the new output
    534              x[0] = sample;
    535              for(i = 0; i < Ntap; i++) {
    536          		y += (s32)FIRCoef[i] * x[i];
    537          	}
    538          	
    539          	if (y >= 0) {
    540          		y = y >> 9;
    541          	}else{
    542          		y = y / DCgain;	
    543          	}
    544          __enable_interrupt();	
    545              return y;	// / DCgain;
    546          }
    547          
    548          
    549          //s16	adc_back1[ADC_SAMPLES_NUMBER];
    550          
    551          volatile s16	d1, d2, d3, d4;
    552          
    553          #define EXT_ARRAY_LEN	7
    554          
    555          //--------------------------------------------------------------------------------
    556          // Function		: void VLO_TimerCalibr(void)
    557          // Parameters	: None
    558          // Return		: 0 - no signal, 1 - signal is existing
    559          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    560          //--------------------------------------------------------------------------------
    561          //#pragma optimize=none
    562          u8 SignalAnalysis(void) {
    563          	int i;
    564          	s16	sample;
    565          	s16 min = 2048, max = -2048;
    566          //	int i_min = 0, i_max = 0;
    567          	u8 array_hi[EXT_ARRAY_LEN] = {0};
    568          	u8 array_lo[EXT_ARRAY_LEN] = {0};
    569          	u8 i_hi = 0;
    570          	u8 i_lo = 0;
    571          	s8 T = 0;
    572          	u8 ret = 0;
    573          	
    574          	// 
    575              for(i = 1; i < Ntap; i++) {
    576          		x[i] = 0;	//signal_array[i] - 220;
    577          	}
    578          	
    579          	sample = AverageData((u16 *)&signal_array[0], 16);
    580          	
    581          	// Filtering with use FIR
    582          	for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
    583          		//signal_array[i] = fir_filter(adc_data1[j++] - 512);
    584          		signal_array[i] = fir_filter(signal_array[i] - sample);	
    585          	}
    586          	
    587          	
    588          	// Searching for of importance of the amplitude of the signal on possible gap of time
    589          	for (i = 10; i < SIGNAL_ARRAY_LEN - 2; i++) {
    590          		sample = signal_array[i];
    591          		if (((sample >  signal_array[i - 1]) && (sample >  signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) ||
    592          		    ((sample >  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) || 
    593          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) )   {
    594          	
    595          			if (sample > 10) {	
    596          				array_hi[i_hi] = i;
    597          				if (i_hi < EXT_ARRAY_LEN - 1) i_hi++;
    598          			}
    599          			
    600          			
    601          		}
    602          		
    603          		if (((sample <  signal_array[i - 1]) && (sample <  signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) ||
    604          		    ((sample <  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) || 
    605          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) )   {
    606          		
    607          			if (sample < (-10)) {	
    608          				array_lo[i_lo] = i;
    609          				if (i_lo < EXT_ARRAY_LEN - 1) i_lo++;
    610          			}
    611          			
    612          		}
    613          			
    614          		if (sample < min) {
    615          			min = sample;
    616          //			i_min = i;
    617          		}
    618          		if (sample > max) {
    619          			max = sample;
    620          //			i_max = i;
    621          		}
    622          	}
    623          
    624          	//
    625          	delta = 0;
    626          	
    627          	if ((i_lo < 2) || (i_hi < 3)) {
    628          		// Low signal
    629          		ret = 1;
    630          	}else{
    631          		T = array_hi[1] - array_hi[0];
    632          		if ((T < 9) || (T > 15))  {
    633          			// High signal
    634          			ret = 2;
    635          		}
    636          	}
    637          	
    638          	d1 = signal_array[array_hi[0]] - signal_array[array_hi[1]];
    639          	if (((d1 < -50) || (d1 > 50)) && (amp_no == 1)){
    640          		// Wery high signal
    641          		ret = 2;
    642          	}
    643          	
    644          	// Definition of delta
    645          	// Define of first low extremum after first hi extremum
    646          	for (i = 0; i < EXT_ARRAY_LEN; i++) {
    647          		if (array_lo[i] > array_hi[0]) {
    648          			i_hi = 0;
    649          			i_lo = i;
    650          			break;
    651          		}
    652          	}
    653          	//
    654          
    655          	
    656          	//i_lo++;
    657          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    658          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo++]];
    659          	d3 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    660          	d4 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    661          
    662          	delta = (d1 + d2 + d3 + d4) / 4;
    663          	
    664          	PWM_period = delta;
    665          	
    666          	if (delta > 4000) {
    667          		delta = 0;	//CONFIG->limit_norm;
    668          	}
    669          	
    670          	if ((DeviceMode == MODE_CALIBR) && ret) {
    671          		delta = 0;
    672          	}
    673          	//
    674          	return ret;
    675          }
    676          
    677          //--------------------------------------------------------------------------------
    678          // Function		: void Timer_A0_SetDelay(u16 period)
    679          // Parameters	: period in us (1..65535) - for 8 MHz DCO
    680          // Return		: None
    681          // Description	: Function initiates delay
    682          //--------------------------------------------------------------------------------
    683          void Timer_A0_SetDelay(u16 period) {
    684          	
    685          	if (period == 0) return;
    686          	
    687          	_BIC_SR(GIE);    					// Запрещаем прерывания
    688          	
    689          	fTimerA_Enable = 1;
    690          	fTimerA_Repeat = 0;
    691          	//
    692          	TA0R = 0;
    693          	TACTL 	 = TASSEL_2 + MC_1 + ID_3;  // SMCLK, up mode, div = 8
    694          	CCR0 	 = period - 1;      		// Period T(us) * F(MHz)
    695                  CCR1 	 = 0;      		// Period T(us) * F(MHz)
    696          	TACCTL0 = CCIE;						// Разрешаем прерывание таймера по достижению значения TACCCR0.
    697          	//
    698          	_BIS_SR(GIE);    					// Разрешаем прерывания
    699          }
    700          //--------------------------------------------------------------------------------
    701          // Function		: void Timer_A0_StartPWM(u16 PulseWidth)
    702          // Parameters	: PulseWidth in us (1..65535) - for 8 MHz DCO
    703          // Return		: None
    704          // Description	: Function initiates PWM 
    705          //--------------------------------------------------------------------------------
    706          #define PWM_PWRIOD      1024
    707          void Timer_A0_StartPWM(u16 PulseWidth){	
    708            u16 tmp = PWM_PWRIOD/PulseWidth;
    709            
    710            if ((PulseWidth == 0) || (f.bTimerA_On == 1) || (f.bTimerA_Repeat ==1))return;
    711          
    712          	_BIC_SR(GIE);    					// Запрещаем прерывания
    713          
    714          	P1SEL |= TEST_OUT_BIT;
    715                  
    716          	if (BCSCTL1 == CALBC1_8MHZ)
    717              TACTL = TASSEL_2 + MC_1 + ID_3;      // SMCLK, up mode, div = 8
    718            else
    719              if(BCSCTL1 == CALBC1_1MHZ)
    720            
    721            TACTL = TASSEL_2 + MC_1;            // SMCLK, up mode, div = 1
    722            TACCTL1 = OUTMOD_7;
    723          //        CCR0 	 = PWM_PWRIOD - 1;
    724          //        CCR1 	 = PulseWidth - 1;      		// Period T(us) * F(MHz)
    725            CCR1 	 = CCR0/tmp;      		// Period T(us) * F(MHz)
    726          
    727            _BIS_SR(GIE);    				// Разрешаем прерывания
    728          }
    729          
    730          void Timer_A0_StopPWM(void){	
    731          	_BIC_SR(GIE);    				// Запрещаем прерывания
    732          	
    733          	P1SEL &= ~TEST_OUT_BIT;
    734          	TEST_OUT_CLR();
    735                  
    736          	CCR0 	 = 0;
    737          	fPWMEnabled = 0;
    738          
    739          	_BIS_SR(GIE);    					// Разрешаем прерывания
    740          }
    741          
    742          void Timer_A0_SetPWMPulse(u16 Pulse){	
    743            
    744          	if (Pulse == 0) return;
    745          	
    746          	_BIC_SR(GIE);    					// Запрещаем прерывания
    747          	CCR0 	 = PWM_PWRIOD - 1;
    748          	CCR1 	 = Pulse - 1;      		// Period T(us) * F(MHz)
    749          	//
    750          	_BIS_SR(GIE);    					// Разрешаем прерывания
    751          }
    752          
    753          //--------------------------------------------------------------------------------
    754          // Function		: void TimerA1_DelayUs(u16 time)
    755          // Parameters	: period in us (1..32768) - for 1 MHz DCO
    756          // Return		: None
    757          // Description	: Function initiates 
    758          //--------------------------------------------------------------------------------
    759          #pragma optimize=none
    760          void TimerA1_DelayUs(u16 time) {
    761          	_BIC_SR(GIE);    					// Запрещаем прерывания
    762          	
    763          	//
    764          	TA1R = 0;
    765          	TA1CTL 	 = TASSEL_2 + MC_1;     	// SMCLK, up mode, div = 8
    766          	TA1CCR0 	 = time - 1 - 35;      	// Period T(us) * F(MHz)
    767          	//
    768          	_BIS_SR(GIE);    					// Разрешаем прерывания
    769          	
    770          	while ((TA1CCTL0 & CCIFG) == 0);
    771          	
    772          	TA1CTL 	 = 0;
    773          	TA1CCTL0 = 0;
    774          
    775          }
    776          
    777          
    778          //--------------------------------------------------------------------------------
    779          // Function		: void Timer_A1_Init(void)
    780          // Parameters	: period in us (1..65535) - for 1 MHz DCO
    781          // Return		: None
    782          // Description	: Function initiates delay
    783          //--------------------------------------------------------------------------------
    784          void Timer_A1_Init(void) {
    785          	_BIC_SR(GIE);    					// Запрещаем прерывания
    786          	//
    787          	TA1R = 0;
    788          	TA1CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    789          	TA1CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    790          	TA1CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
    791          	//
    792          	_BIS_SR(GIE);    					// Разрешаем прерывания
    793          }
    794          
    795          
    796          //--------------------------------------------------------------------------------
    797          // Function		: void SoundStart(u8 snd_ind)
    798          // Parameters	: period in us (1..32768) - for 16 MHz DCO
    799          // Return		: None
    800          // Description	: Function initiates 
    801          //--------------------------------------------------------------------------------
    802          void Timer_A0_Off(void) {
    803          	_BIC_SR(GIE);    			// Запрещаем прерывания
    804          	//	
    805          	fTimerA_Enable = 0;
    806          	fTimerA_Repeat = 0;
    807          	//
    808                  P1SEL &= ~TEST_OUT_BIT;
    809                  TEST_OUT_CLR();
    810                  
    811          	TACTL = 0;  
    812          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    813          	//
    814          	_BIS_SR(GIE);    			// Разрешаем прерывания
    815          
    816          }
    817          
    818          
    819          //--------------------------------------------------------------------------------
    820          // Function		: void SetFaultMode(void)
    821          // Parameters	: None
    822          // Return		: None
    823          // Description	: 
    824          //--------------------------------------------------------------------------------
    825          void SetFaultMode(void) {
    826          	
    827          	DeviceMode = MODE_FAULT;
    828          	//
    829          
    830          	if (fault_timer == 0) { 
    831          		// No faults
    832          		fault_timer = 1000;		// 10 sec
    833          		fault_phase = 1;		// Break of BI
    834          	}
    835          
    836          	//
    837          //	strob_pulse_timer = 0;		// Clear strob timer because there is breaking BI
    838          }
    839          
    840          
    841          
    842          //--------------------------------------------------------------------------------
    843          // Function		: void FaultSignalManager(void)
    844          // Parameters	: None
    845          // Return		: None
    846          // Description	: Call one time per 10 ms
    847          //--------------------------------------------------------------------------------
    848          void FaultSignalManager(void) {
    849          	
    850          	if ((DeviceMode == MODE_FIRE) || (DeviceMode == MODE_TEST) || (DeviceMode == MODE_CALIBR)) {
    851          		return;
    852          	}
    853          	//
    854          	if (DeviceFault.byte) {
    855          		DeviceMode = MODE_FAULT;
    856          		led_r = 0;
    857          
    858          		if (DeviceFault.fSignal_Low) {
    859          			// Level signal is very low
    860          			led_y = LED_PULSE_1;
    861          		}else	
    862          		if (DeviceFault.fFaultDrift) {
    863          			// Long Term Drift fault
    864          		led_y = LED_PULSE_3;
    865          		}else	
    866          		if (DeviceFault.fFaultCRC) {
    867          			// Long Term Drift fault
    868          		led_y = LED_PULSE_4;
    869          		}else	
    870          		if (DeviceFault.fSignal_Hi) {
    871          		// Level signal is very big
    872          		led_y = LED_PULSE_5;
    873          		}
    874          	}
    875          	
    876          	
    877          		if (CalibrFault.byte) {
    878          		// Calibration fault signals
    879          		
    880          		DeviceMode = MODE_FAULT;
    881          		led_r = 0;
    882          		
    883          		if (CalibrFault.fCalibr_Low) {
    884          			led_y = LED_PULSE_4;
    885          		}else
    886          		if (CalibrFault.fCalibr_Hi) {
    887          			led_y = LED_PULSE_5;
    888          		}
    889          
    890          		fault_timer = 0;
    891          		fault_phase = 0;
    892          	}
    893          		
    894          	if ((DeviceFault.byte == 0) && (CalibrFault.byte == 0)) {
    895          		if (DeviceMode == MODE_FAULT) {
    896          			DeviceMode = MODE_NORM;
    897          			
    898          			led_r = 0;
    899          			led_y = 0;
    900          			fault_timer = 0;
    901          			fault_phase = 0;
    902           
    903          			NFAULT_SET();
    904          
    905          		}
    906          	}
    907          	//
    908          
    909          	if (0 != fault_timer) {
    910          		fault_timer--;
    911          		//
    912          		if (fault_timer == 0) {
    913          			if (fault_phase) {
    914          				fault_phase = 0;
    915          				fault_timer = 2000;		// 20 sec
    916          			}else{
    917          				fault_phase = 1;
    918          				fault_timer = 1000;		// 10 sec
    919          			}
    920          		}
    921          		//
    922          		if (fault_phase == 1) {
    923          			NFAULT_CLR();
    924          		}else{
    925          			NFAULT_SET();
    926          		}
    927          	}
    928          }
    929          
    930          
    931          //--------------------------------------------------------------------------------
    932          // Function		: void LedTestValueManager(void)
    933          // Parameters	: None
    934          // Return		: None
    935          // Description	: 
    936          //--------------------------------------------------------------------------------
    937          //#pragma optimize=none
    938          void LedTestValueManager(void) {
    939          	if (delta < 150) {
    940          		led_r = LED_PULSE_1;
    941          		led_y = LED_FULL;
    942          	}else
    943          	if (delta < 250) {
    944          		led_r = LED_PULSE_2;
    945          		led_y = LED_FULL;
    946          	}else
    947          	if (delta < 450) {
    948          		led_r = LED_PULSE_3;
    949          		led_y = LED_FULL;
    950          	}else
    951          	if (delta < 550) {
    952          		led_r = LED_PULSE_4;
    953          		led_y = LED_FULL;
    954          	}else{
    955          		led_r = LED_PULSE_5;
    956          		led_y = LED_FULL;
    957          	}
    958          }
    959          
    960          
    961          //---------------------------------------------------------------------------------
    962          // Function		: void AMP_SetGain(u8 value)
    963          // Parameters	: None
    964          // Return		: None
    965          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
    966          //---------------------------------------------------------------------------------
    967          void ADC_SetParam(void) {
    968          	gain = CONFIG->Gain & 0x0F;
    969          	reference = CONFIG->Gain >> 4;
    970          	amp_no = CONFIG->AMP_No;
    971          }
    972          
    973          //---------------------------------------------------------------------------------
    974          // Function		: void AMP_SetGain(u8 value)
    975          // Parameters	: None
    976          // Return		: None
    977          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
    978          //---------------------------------------------------------------------------------
    979          #pragma optimize=none
    980          void CalibrationResultAnalise(void) {
    981          	int i;
    982          	u16 prev, temp, min = 0xFFFF, max = 0;
    983          	u8  i_ok = 0xFF, i_ok2 = 0xFF;
    984          	u8  fault = 0;
    985          	u16 d;
    986          	u8  corr = 0;
    987          	
    988          	prev = s_array[0];
    989          	for (i = 0; i < CALIBR_STAGES; i++) {
    990          		temp = s_array[i];
    991          		//
    992          		if (temp > max) {
    993          			max = temp;
    994          		}
    995          		if (temp < min) {
    996          			min = temp;
    997          		}
    998          			
    999          		if (((temp >= 90) && (temp <= 200)) || 
   1000          			((temp >= 480) && (temp <= 600))) {
   1001          			i_ok = i;
   1002          			break;
   1003          		}
   1004          		if ((temp >= 200) && (temp <= 480)) {
   1005          			i_ok2 = i;
   1006          			break;
   1007          		}
   1008          		//
   1009          		if ((prev > 100) && (temp == 0) && (i <= 4)) {
   1010          			fault = 1;	// Signal is vefy Hi
   1011          		}
   1012          		prev = temp;
   1013          	}
   1014          	//
   1015          	if (q_array[0] == 2) {
   1016          		// Signal is vefy Hi
   1017          		fault = 1;
   1018          	}
   1019          	//
   1020          		
   1021          	if (fault) {
   1022          		// End of calibration - very Hi signal - ERROR
   1023          		//DeviceFault.fSignal_Hi = 1;
   1024          		//DeviceMode = MODE_FAULT;
   1025          		CalibrFault.fCalibr_Hi = 1;
   1026          	}else
   1027          	if ((i_ok2 < CALIBR_STAGES) || (i_ok < CALIBR_STAGES)) {
   1028          		if (i_ok2 < CALIBR_STAGES) {
   1029          			i = i_ok2; 
   1030          		}else{
   1031          			i = i_ok;
   1032          		}
   1033          		//
   1034          		// Calibration Ok!!!
   1035          		//
   1036          		d = s_array[i];
   1037          		//q = q_array[i]; 
   1038          		//
   1039          
   1040          	
   1041          		if (i == 0) {
   1042          			if (d >= 480) {
   1043          				CalibrFault.fCalibr_Hi = 1;
   1044          				goto label_return;
   1045          				//StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1046          				//return;
   1047          			}
   1048          			//
   1049          
   1050          			if (d >= 330) {
   1051          				corr = 2;
   1052          			}else
   1053          			if (d >= 170) {
   1054          				corr = 1;
   1055          			}
   1056          
   1057          		}
   1058          /*
   1059          			if (CALIBR_STAGES - 2 <= i)
   1060          		{
   1061          			corr = 1;
   1062          		}
   1063          	*/		
   1064          		// That's Ok
   1065          		//SetLevels(d);
   1066          		SetLevelsFromCalibr(d, corr);
   1067          		SetLimitCompens();
   1068          		
   1069          		amp_no = calibr_sequence[i][0];
   1070          		gain = calibr_sequence[i][1];
   1071          		reference = calibr_sequence[i][2];
   1072          		
   1073          		StoragePropertyByte(ee_GAIN, gain + (reference << 4));
   1074          		StoragePropertyByte(ee_AMP_NO, amp_no);
   1075          		StoragePropertyWord(eeCONFIG_REG_OFFSET, cfg_reg.word);
   1076          		//
   1077          		DeviceMode = MODE_NORM;
   1078          
   1079          //DL3   
   1080          		NFAULT_SET();
   1081          
   1082          
   1083          		//
   1084          		AMP_SetGain(gain);
   1085          		//
   1086          	}else
   1087          	if (max < SYGNAL_MIN_VALUE) {
   1088          		// Signal is Low
   1089          		CalibrFault.fCalibr_Low = 1;
   1090          	}else
   1091          	if (min > SYGNAL_MAX_VALUE) {
   1092          		// Signal is Hi
   1093          		CalibrFault.fCalibr_Hi = 1;
   1094          	}
   1095          	//
   1096          //DL3   
   1097          label_return:
   1098          	NFAULT_SET();
   1099          	StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1100          
   1101          	#if (1 == CRC_ENABLE)	
   1102          	DeviceFault.fFaultCRC = 0;
   1103          	SavePropertyCS();
   1104          	#endif
   1105          
   1106          }
   1107          	
   1108          
   1109          //========================================================
   1110          //                 ---  M A I N  ----
   1111          //========================================================
   1112          //--------------------------------------------------------------------------------
   1113          // Function		: void main(void)
   1114          // Parameters	: None
   1115          // Return		: None
   1116          // Description	: Main function. Contains main loop.
   1117          //--------------------------------------------------------------------------------
   1118          void main(void) {
   1119          	u8	byte, sh, len, irpulses = 3, fADCStarted = 0;
   1120          	int i;
   1121          	u8  loc_buf[2];
   1122          	u8  n_counter = 0;
   1123          	u8  quality;
   1124          	u16	summa = 0;
   1125          	u8	fire_level_counter = 0;
   1126          	u8	QualityFaultCounter = 0;
   1127          	u8	led_clk;
   1128          	u16	led_timer = 0;
   1129          	u8	timerA1_blank = 0;
   1130          	
   1131          	// Initialization variables and GPIO
   1132          	WDTCTL = WDTPW + WDTHOLD;				// отключаем сторожевой таймер
   1133          	// GIPIO Init
   1134          	GPIO_Init();
   1135          		
   1136          	// Init internal RC osc.
   1137          	BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1138          	DCOCTL =  CALDCO_1MHZ;
   1139          	
   1140          	DelayMs(100);
   1141          	
   1142          	// Initialization code for VLO
   1143          	__set_R4_register(0);
   1144          	//
   1145          	BCSCTL3 |= LFXT1S_2;                    // Select VLO as low freq clock
   1146          	// End initialization code
   1147          	
   1148          	WDTCTL = WDT_ADLY_16;                   // Interval timer	/* for 50 ms */
   1149          	//WDTCTL = WDT_ADLY_1_9;                   // Interval timer	/* for 5.9 ms */
   1150          	IE1 |= WDTIE;                           // Enable WDT interrupt
   1151          	//
   1152          	if (IFG1 & WDTIFG) {
   1153          		// Reset WDT
   1154          		#if (SYS_FAULT_ENABLE == 1)
   1155          		DeviceFault.fFaultSWReset = 1;
   1156          		#endif
   1157          	}
   1158          	IFG1 = 0;
   1159          	//	
   1160          	DeviceMode = MODE_NORM;
   1161          	
   1162          	//!!!!
   1163          	CH_IN_DIR |= CH_IN_BIT;
   1164                  
   1165          //DL3   
   1166                  NFAULT_SET();
   1167          //        fPWMEnabled = 0;
   1168          //DL3   	
   1169          	DelayMs(4000);
   1170                  
   1171          	Led_Flash(1);
   1172          	DelayMs(300);
   1173          	Led_Flash(1);
   1174          	
   1175          //	BREAK_DISABLE();					// Enable BI
   1176          	DelayMs(1000);
   1177          	
   1178          	_BIS_SR(GIE);    					// Interrupt enable
   1179          	DeviceStart();
   1180          
   1181          
   1182          
   1183          	AMP_SetGain(CONFIG->Gain);
   1184          	ADC_SetParam();
   1185          	cfg_reg = CONFIG->config_reg;
   1186          	
   1187          	Timer_A1_Init();
   1188          	
   1189          //	DelayMs(2000);
   1190          	
   1191          	start_timer = 400;		// 4 sec
   1192          // *****************************************************************
   1193          // ******************   M A I N   L O O P  *************************
   1194          // *****************************************************************
   1195          	while(1) {
   1196          		//-------------------------------------------------------------------------------
   1197          		//
   1198          		// ******** Обработчики событий ********
   1199          		//
   1200          		//-------------------------------------------------------------------------------
   1201          		
   1202          //-------------------------------------------------------------------------------
   1203          // TimerA0 Event		
   1204          //-------------------------------------------------------------------------------
   1205                    
   1206          		if (fTimerA_On) {				// Закончен период ожидания измерительных импульсов
   1207          			fTimerA_On = 0;
   1208                            
   1209                BCSCTL1 = CALBC1_16MHZ; 	// Используем частоту 16 MГц
   1210                DCOCTL =  CALDCO_16MHZ;
   1211                                    //
   1212                TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1213                                    //
   1214                Timer_A0_Off();				
   1215                                    
   1216                ADC_MeasureStart();
   1217                                    
   1218                fADCStarted =1;
   1219                                    
   1220          
   1221                timerA1_blank = 0;
   1222            //Added for DL3
   1223          			if(1 == fADCStarted){
   1224                	fADCStarted = 0;
   1225          				while(irpulses){
   1226          					IRED_SET();
   1227          					DelayUs(1000);
   1228          					IRED_CLR();
   1229          					DelayUs(1000);
   1230          					irpulses--;
   1231          				}
   1232          				irpulses = 3;
   1233          			}
   1234          
   1235          		}
   1236          
   1237          //-------------------------------------------------------------------------------
   1238          // fTimer50msOn Event				
   1239          //-------------------------------------------------------------------------------
   1240          		if (fTimer50msOn) {		// Получен следующий 50мс интервал
   1241          			fTimer50msOn = 0;
   1242          			//
   1243          			Timer50msCounter = 0;
   1244          		}
   1245          		
   1246          //-------------------------------------------------------------------------------
   1247          // TimerA1 Event (SysTick) 10 ms
   1248          //-------------------------------------------------------------------------------
   1249          		if (fTimerA1_On) {				// Получен следующий интервал timer
   1250          			fTimerA1_On = 0;
   1251          			
   1252          			if(start_timer){
   1253                  start_timer--;
   1254                  if (start_timer == 0) {
   1255                  CalibrFault.byte = CONFIG->calibr_fault;
   1256                  flash_period_timer = 500;	// Need flash after 5 sec
   1257                  strob_pulse_timer = 0;
   1258          				}
   1259          			}
   1260          			
   1261          			if (timerKeyDown) {
   1262          				timerKeyDown++;
   1263          				if (timerKeyDown > 200 ) {			// > 2 sec - Start Calibration
   1264          
   1265          					// CALIBRATION Start
   1266          					JP1_Define();			// Define JP1 on BVS state
   1267          					if (jp1_state == 0) {
   1268          						// JP1 is Open 
   1269          						cfg_reg.fDrift = 1;
   1270          					}else{
   1271          						cfg_reg.fDrift = 0;
   1272          					}
   1273                                                  
   1274          					//
   1275          					// Calibration mode init 
   1276          					DeviceMode = MODE_CALIBR;
   1277          					fPWMEnabled = 1;
   1278          
   1279          					// Calibration from most amp to small
   1280          //DL3			
   1281          					NFAULT_SET();
   1282          
   1283          					DeviceFault.fStrobNone = 0;
   1284          					strob_pulse_timer = 0;
   1285          
   1286          					calibr_stage = 0;
   1287          					n_counter = 0;
   1288          					summa = 0;
   1289          					//
   1290          					amp_no = calibr_sequence[calibr_stage][0];
   1291          					gain = calibr_sequence[calibr_stage][1];
   1292          					reference = calibr_sequence[calibr_stage][2];
   1293          					//
   1294          					AMP_SetGain(gain);
   1295          					
   1296          					QualityFaultCounter = 0;
   1297          					DeviceFault.byte = 0;
   1298          					CalibrFault.byte = 0;
   1299          					fault_timer = 0;
   1300          					fault_phase = 0;
   1301          					
   1302          					RED_CLR();
   1303          					YEL_CLR();
   1304          					
   1305          					timerKeyDown = 0;
   1306          					
   1307          					flash_period_timer = 120;	// Flash after 1.2 sec
   1308          					light_timer = 7;			// Value - the power of LED light
   1309          				}
   1310          			}
   1311          			
   1312          			if (zero_timer) {
   1313          				zero_timer++;
   1314          			}
   1315          				
   1316          			if (fault_chain_timer)  {
   1317          				fault_chain_timer--;
   1318          				if (DeviceMode != MODE_FIRE) {
   1319          					if (fault_chain_timer == 0) {
   1320          						if (fault_sequence[fault_chain_ind] == 0) {
   1321          							fault_chain_ind = 0;
   1322          							DeviceMode = MODE_NORM;
   1323          						}else{
   1324          							DeviceMode = fault_sequence[fault_chain_ind++];
   1325          							fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1326          							//
   1327          							switch (DeviceMode) {
   1328          								case MODE_FIRE:
   1329          									FIRE_SET();
   1330          									//
   1331          									RED_SET();
   1332          									YEL_CLR();
   1333          									fault_chain_timer = 0;
   1334          
   1335          									zero_timer = 0;
   1336          									DeviceFault.fSignal_Low = 0;
   1337          									break;
   1338          								case MODE_FAULT:
   1339          										NFAULT_CLR();
   1340                              break;
   1341          								case MODE_NORM:
   1342          										zero_timer = 0;
   1343          										DeviceFault.fSignal_Low = 0;
   1344          										NFAULT_SET();
   1345          							}
   1346          						}
   1347          					}
   1348          				}
   1349          			}
   1350          			
   1351          			if (timerMain) {
   1352          				timerMain--;
   1353          				if (timerMain == 0) {
   1354          					if (DeviceMode == MODE_TEST) {
   1355          						DeviceMode = MODE_NORM;
   1356          						RED_CLR();
   1357          						YEL_CLR();
   1358          						
   1359          						NFAULT_SET();
   1360          					}
   1361          				}
   1362          			}
   1363          			//
   1364          			// Setting signals in Fault Mode (LEDs and other pins)
   1365          			FaultSignalManager();
   1366          			//
   1367          			
   1368          			if (timerA1_blank) {
   1369          				timerA1_blank--;
   1370          			}else{
   1371          				// ---- LED Indication ----
   1372          				//
   1373          				if (light_timer) {
   1374          					light_timer--;
   1375          					//
   1376          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1377          						RED_SET();
   1378          						YEL_CLR();
   1379          					}else
   1380          					//
   1381          					if (DeviceMode == MODE_CALIBR) {
   1382          						RED_SET();
   1383          						YEL_SET();
   1384          					}
   1385          				}else{
   1386          					//
   1387          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_CALIBR) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1388                                                          RED_CLR();
   1389          						YEL_CLR();
   1390          					}
   1391          				}
   1392          				//	
   1393          				if ((DeviceMode == MODE_FAULT) || (DeviceMode == MODE_TEST)) {
   1394          					//
   1395          					// LED management
   1396          					//
   1397          					if (light_sync >= 3) {
   1398          						light_sync = 0;
   1399          						led_sh = 0x80000000;
   1400          						//
   1401          						led_timer = 300;	// 3 sec period
   1402          					}
   1403          					
   1404          					if (led_timer) {
   1405          						led_timer--;
   1406          					}else{
   1407          						led_timer = 300;	// 3 sec period
   1408          						led_sh = 0x80000000;
   1409          						//
   1410          						light_sync = 0;
   1411          					}
   1412          					//
   1413          					if (++led_clk >= 4) {		// T = 30 ms
   1414          						led_clk = 0;
   1415          						//
   1416          						if (led_r & led_sh) {
   1417          							RED_SET();
   1418          //							CH_IN_SET();
   1419          						}else{
   1420          							RED_CLR();
   1421          //							CH_IN_CLR();
   1422          						}
   1423          						//
   1424          						if (led_y & led_sh) {
   1425          							YEL_SET(); 
   1426          						}else{
   1427          							YEL_CLR();
   1428          						}
   1429          						//
   1430          						if (DeviceMode == MODE_TEST) {
   1431          							YEL_SET(); 
   1432          						}
   1433          						//
   1434          						led_sh >>= 1;
   1435          					}
   1436          				}
   1437          			} // End indication
   1438          
   1439          // Added for DL3
   1440                                  if(DeviceMode == MODE_FIRE){
   1441                                    fStartPulse = 0;
   1442                                  }
   1443                                  else
   1444                                    if (strob_pulse_timer == 0) {
   1445                                      fStartPulse = 1;                        
   1446                                      strob_pulse_timer = 120;
   1447                                    }
   1448                                    else{
   1449                                      strob_pulse_timer--;
   1450                                    }
   1451          
   1452          //DL3 PWM 
   1453                                    if(fPWMEnabled){
   1454                                            Timer_A0_StartPWM(PWM_period);
   1455                                          }
   1456          //end DL3 PWM      
   1457          //end  Added for DL3
   1458          
   1459          			//
   1460          			if (flash_period_timer) {
   1461          				flash_period_timer--;
   1462          				if (flash_period_timer == 0) {
   1463          					flash_period_timer = 120;	// Flash after 1.2 sec
   1464          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)){
   1465          						light_timer = 1;				// Value - the light power
   1466          					}else
   1467          					if (DeviceMode == MODE_CALIBR) {
   1468          						light_timer = 7;				// Value - the light power
   1469          					}
   1470          				}
   1471          			}
   1472                                  
   1473          		} // if (fTimerA1_On 10 ms)
   1474          		
   1475          //-------------------------------------------------------------------------------
   1476          // End of samples of ADC Event
   1477          		if (fEndOfSamples) {	// End of samples of ADC Event
   1478          			fEndOfSamples = 0;
   1479          		
   1480          			//VREF_Off();						// Vref Disable
   1481          			ADC10CTL0 &= ~ENC;
   1482          			while (ADC10CTL1 & BUSY);           // Wait if ADC10 core is active 
   1483          			ADC10CTL0 &= ~REFON;
   1484          			
   1485          			AMP_PWR_OFF();						// AMP Power Supply Disable
   1486          			//AMP_Off_Timer = CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;	//CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;
   1487          			//
   1488          
   1489          			BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 8 MГц
   1490          			DCOCTL =  CALDCO_8MHZ;
   1491          			//
   1492          			TA1CCR0  = 0xFFFF - 1;   			// ~ Compensation of frequence increase
   1493          			//
   1494          			DelayUs(1);
   1495          			//
   1496          			if (fSendingGraph) {
   1497          				loc_buf[0] = Q_SEND_GRAPH1;
   1498          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1499          				SoftUART_TxString(loc_buf, 2);
   1500          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1501          
   1502          
   1503          			}
   1504          			//
   1505          			if((DeviceMode == MODE_TEST) ||(DeviceMode == MODE_FAULT)){
   1506                	fPWMEnabled = 1;  
   1507                  Timer_A0_StartPWM(PWM_period);
   1508                }
   1509          /*
   1510          			else{
   1511                	fPWMEnabled = 0;  
   1512          			}
   1513          */			
   1514          			if (start_timer || CalibrFault.byte || DeviceFault.fFaultDrift) {
   1515          				goto label_light;
   1516          			}         
   1517          			
   1518          			quality = SignalAnalysis();
   1519          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1520          			DCOCTL =  CALDCO_1MHZ;
   1521          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1522          			DelayUs(1);
   1523                                  
   1524          			//
   1525          			if (DeviceMode == MODE_CALIBR) {
   1526          				//
   1527          				// -------- КАЛИБРОВКА ---------
   1528          				//
   1529          				n_counter++;
   1530          				summa += delta;
   1531          				
   1532          				if (n_counter >= 2) {
   1533          					delta = summa / n_counter;
   1534          		
   1535          					n_counter = 0;
   1536          					summa = 0;
   1537          					//
   1538          					s_array[calibr_stage] = delta;
   1539          					q_array[calibr_stage] = quality;
   1540          					//
   1541          					if (++calibr_stage >= CALIBR_STAGES) {
   1542          						// End of calibration
   1543          						//
   1544          						CalibrationResultAnalise();
   1545          						if (CalibrFault.byte) {
   1546          							DeviceMode = MODE_FAULT;
   1547          						}
   1548          						//
   1549          						goto label_light;
   1550          					}
   1551          					//
   1552          					//	Set new	 Amp_No	Gain  Reference
   1553          					amp_no = calibr_sequence[calibr_stage][0];
   1554          					gain = calibr_sequence[calibr_stage][1];
   1555          					reference = calibr_sequence[calibr_stage][2];
   1556          					//
   1557          					AMP_SetGain(gain);
   1558          					//
   1559          				}
   1560          			}else
   1561          			
   1562          			// Дежурный режим
   1563          			//
   1564          			if (quality == 2) {	
   1565          				// Very high signal
   1566          				if (++QualityFaultCounter > 10) {
   1567          					CalibrFault.fCalibr_Hi = 1;
   1568          					QualityFaultCounter = 0;
   1569          				}
   1570          				//
   1571          				goto label_light;
   1572          			}else{
   1573          				QualityFaultCounter = 0;
   1574          			}
   1575          			
   1576          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && fault_chain_timer) {
   1577          				// Обрабатывается полное перекрытие
   1578          				if (delta > getZeroLevel()) {
   1579          					fault_chain_timer = 0;
   1580          					fault_chain_ind = 0;
   1581          					DeviceFault.fSignal_Low = 0;
   1582          				}
   1583          			}
   1584          			
   1585          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && (fault_chain_timer == 0)) {
   1586          				if ((delta >= CONFIG->limit_fire) && (delta <= SYGNAL_MAX_VALUE)) {
   1587          					// Reset all counters
   1588          					fire_level_counter = 0;
   1589          					hi_signal_counter = 0;
   1590          					zero_timer = 0;
   1591          				}
   1592          								
   1593          				if (delta <= getZeroLevel()) {
   1594          					if (zero_timer == 0) {	
   1595          						zero_timer = 1;
   1596          					}else
   1597          					if (zero_timer > 1000) {	// 10 sec
   1598          						// Полное перекрытие 
   1599          						fault_chain_ind = 0;
   1600          						DeviceMode = fault_sequence[fault_chain_ind++];
   1601          						fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1602          						DeviceFault.fSignal_Low = 1;
   1603          						zero_timer = 0;
   1604          						//
   1605          						NFAULT_CLR();
   1606          
   1607          						//
   1608          					}
   1609          				}else{
   1610          					zero_timer = 0;
   1611          					//
   1612          					if (delta < CONFIG->limit_prefire) {
   1613          						DeviceMode = MODE_PREPREFIRE;
   1614          					}
   1615          					
   1616          					if (DeviceMode == MODE_PREPREFIRE) {
   1617          						if (delta > CONFIG->limit_prefire) {
   1618          							DeviceMode = MODE_NORM;
   1619          						}
   1620          					}
   1621          					
   1622          					if (delta < CONFIG->limit_fire) {
   1623          						fire_level_counter = 5;
   1624          						DeviceMode = MODE_PREFIRE;
   1625          					}
   1626          					
   1627          					// Hi signal management
   1628          					if (delta > SYGNAL_MAX_VALUE) {
   1629          						// Very high signal
   1630          						hi_signal_counter++;
   1631          						if (hi_signal_counter >= 10) {
   1632          							//DeviceMode = MODE_FAULT;
   1633          							CalibrFault.fCalibr_Hi = 1;
   1634          							hi_signal_counter = 0;
   1635          						}
   1636          					}
   1637          				}
   1638          			}else
   1639          			if (DeviceMode == MODE_PREFIRE) {
   1640          				//
   1641          				// Защита от плавного изменения уровня сигнала
   1642          				if ((delta == 0) && (delta_last > 0)) {
   1643          					fire_level_counter = 10;
   1644          				}
   1645          				//	
   1646          				if ((delta <= getZeroLevel()) && (fire_level_counter == 5)) {
   1647          					if (zero_timer == 0) {	
   1648          						zero_timer = 1;
   1649          						DeviceMode = MODE_NORM;
   1650          					}
   1651          				}else
   1652          				if (delta < CONFIG->limit_fire) {
   1653          					if (--fire_level_counter == 0) {
   1654          						DeviceMode = MODE_FIRE;
   1655          						FIRE_SET();
   1656          						RED_SET();
   1657          						YEL_CLR();
   1658          						DeviceFault.byte = 0;
   1659          					}
   1660          				}else{
   1661          					DeviceMode = MODE_NORM;
   1662          				}
   1663          				//
   1664          				delta_last = delta;
   1665          			}
   1666          			//
   1667          			if (CONFIG->config_reg.fDrift) {
   1668          				// if JP1 state is open
   1669          				if ((DeviceMode == MODE_NORM) && delta) {
   1670          					// Long Term Drift Adjustment
   1671          					DriftSumma += delta;
   1672          					DriftCounter++;
   1673          					if (DriftCounter >= DRIFT_SAMPLES_MAX) {
   1674          						DriftLevel = DriftSumma / DriftCounter;
   1675          						//
   1676          						if ((u16)DriftLevel < CONFIG->limit_drift) {
   1677          							//
   1678          							DeviceFault.fFaultDrift = 1;
   1679          							SetFaultMode();
   1680          							//
   1681          							SetLevels(CONFIG->limit_drift);
   1682          						}else{
   1683          							SetLevels((u16)DriftLevel);
   1684          						}
   1685          						//	
   1686          						ClearDriftVar();
   1687          						//
   1688          					}
   1689          				}
   1690          			}
   1691          			//			
   1692          			//
   1693          label_light:			
   1694          			//
   1695          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1696          			DCOCTL =  CALDCO_1MHZ;
   1697          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1698          			//
   1699          			DelayUs(1);
   1700          			//
   1701          
   1702                                  if (fSendingGraph) {
   1703          //DL3
   1704          
   1705          
   1706          				BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 8 MГц
   1707          				DCOCTL =  CALDCO_8MHZ;
   1708          				TA1CCR0  = 0xFFFF - 1;   				// ~ Compensation of frequence increase
   1709          				//
   1710          				//
   1711          				for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
   1712          					signal_array[i] += 350;
   1713          				}
   1714          				
   1715          				loc_buf[0] = Q_SEND_GRAPH2;
   1716          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1717          				SoftUART_TxString(loc_buf, 2);
   1718          				//
   1719          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1720          				
   1721          				SoftUART_TxString((u8*)&delta, 2);
   1722          				
   1723          				fSendingGraph = 0;
   1724          				//
   1725          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1726          				DCOCTL =  CALDCO_1MHZ;
   1727          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1728          				//
   1729          
   1730          //end DL3
   1731          			}
   1732          			//
   1733          			//
   1734          			// Indication
   1735          			//
   1736          			if (DeviceMode == MODE_NORM) {
   1737          				light_timer = 1;				// Value - the light power
   1738          				flash_period_timer = 120;		// Flash after 1.2 sec
   1739          //				flash_period_timer = 200;		// Flash after 2 sec
   1740          			}
   1741          			//
   1742          			if ((DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1743          				light_timer = 4;				// Value - the light power
   1744          				flash_period_timer = 120;		// Flash after 1.2 sec
   1745          //				flash_period_timer = 60;		// Flash after 1.2 sec
   1746          			}
   1747          			//
   1748          			if (DeviceMode == MODE_CALIBR) {
   1749          				light_timer = 7;				// Value - the light power
   1750          				flash_period_timer = 120;		// Flash after 1.2 sec
   1751          			}
   1752          			//
   1753          			if (DeviceMode == MODE_TEST) {
   1754          				// Indication sygnal level
   1755          				LedTestValueManager();			
   1756          				//
   1757          			}
   1758          			//
   1759          			light_sync++;
   1760          			led_timer = 400;	//4 sec
   1761          //			STROB_IE_Enable();
   1762          		}
   1763          		
   1764          //-------------------------------------------------------------------------------
   1765          // Strobe StartPulse Event		
   1766          		if (fStartPulse) {			// Start pulse was received
   1767          			fStartPulse = 0;
   1768          	
   1769          
   1770          			//
   1771          			AMP_PWR_ON();						// AMP Power Supply Enable
   1772          			// Vref Enable
   1773          			if (DeviceMode == MODE_CALIBR) {
   1774          				ADC_MeasureInit(amp_no, reference);
   1775          			}else{
   1776          				ADC_MeasureInit(CONFIG->AMP_No, reference);
   1777          			}
   1778          			
   1779          			_BIC_SR(GIE);    			// Запрещаем прерывания
   1780          
   1781          //DL3                        Timer_A0_SetDelay(2250);
   1782          			Timer_A0_StopPWM();
   1783                Timer_A0_SetDelay(1500);
   1784          //                        
   1785          			_BIS_SR(GIE);    			// Разрешаем прерывания
   1786          			//
   1787          			BCSCTL1 = CALBC1_8MHZ; 		// Используем частоту 8 MГц
   1788          			DCOCTL =  CALDCO_8MHZ;
   1789          			//
   1790          			TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1791          			//
   1792          			// For define the presence of strob pulses
   1793          //DL3			strob_pulse_timer = 0;
   1794                                  
   1795          			DeviceFault.fStrobNone = 0;
   1796          			//
   1797          			fault_phase = 0;
   1798          			fault_timer = 0;
   1799          		}
   1800          		
   1801          
   1802          //-------------------------------------------------------------------------------
   1803          // KEY DOWN event		
   1804          		if (fButtonDownOn) {									// Нажата кнопка
   1805          			fButtonDownOn = 0;
   1806          			//...
   1807          			timerKeyDown = 1;
   1808          			//
   1809          		} // if (fButtonDownOn)
   1810          		
   1811          //-------------------------------------------------------------------------------
   1812          // KEY UP event
   1813          		if (fButtonUpOn) {			// Отжата кнопка
   1814          			fButtonUpOn = 0;
   1815          
   1816          			if ((timerKeyDown > 4) && (timerKeyDown < 150))  {	// < 1.5 sec
   1817          				// The short pressure on the button
   1818          				if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)|| (DeviceMode == MODE_FAULT)) {
   1819          //DL3
   1820          					prevDeviceMode = DeviceMode;			//save current mode to be restored after test mode
   1821          					DeviceMode = MODE_TEST;
   1822          					prevDeviceFault = DeviceFault;
   1823          					DeviceFault.byte = 0;	// Reset all faults
   1824          
   1825          //DL3                                   FIRE_SET();				// Set fire mode current consumption
   1826          					NFAULT_SET();
   1827          //DL3 
   1828          					RED_CLR();
   1829          					YEL_SET();
   1830          					timerMain = 12000;		// 120 sec
   1831          					led_sh = 0;
   1832          					led_timer = 0;			// Устраняем задержку оптической индикации
   1833          					led_clk = 0xFF;
   1834                                                  
   1835                                                  fPWMEnabled = 1;
   1836          				}else
   1837          				//	
   1838          				if (DeviceMode == MODE_TEST) {
   1839          					DeviceMode = prevDeviceMode;
   1840          					DeviceFault = prevDeviceFault;
   1841          /*DL3						
   1842          					DeviceMode = MODE_NORM;
   1843          					DeviceFault.byte = 0;	// Reset all faults
   1844          
   1845          */
   1846          					led_timer = 0;
   1847          					RED_CLR();
   1848          					YEL_CLR();
   1849          //
   1850          					NFAULT_SET();
   1851          //DL3 
   1852          				}else
   1853          				//
   1854          				if (DeviceMode == MODE_FIRE) {
   1855          					DeviceMode = MODE_NORM;
   1856          					DeviceFault.byte = 0;	// Reset all faults
   1857          					RED_CLR();
   1858          					YEL_CLR();
   1859          
   1860          //DL3 
   1861          					FIRE_CLR();				// Disable Fire Output
   1862                                                  NFAULT_SET();
   1863          //DL3 
   1864          					led_r = 0;
   1865          					led_y = 0;
   1866          				}
   1867          			}
   1868          			//
   1869          			timerKeyDown = 0;
   1870          		} // if (fButtonUpOn) {
   1871          
   1872          		
   1873          //-------------------------------------------------------------------------------
   1874          // Soft UART Rx Hundler
   1875          		if (fRxLineDownOn) {
   1876          
   1877          			uart_rx_ind = 0;
   1878          // DL3
   1879          			//
   1880          label_rx_continue:
   1881          			fRxLineDownOn = 0;
   1882          			//
   1883          			DelayUs_8MHz(25);		// Delay to center of pulse
   1884          			//
   1885          			CH_IN_SET();
   1886          			CH_IN_CLR();
   1887          			//
   1888          			if ((INTER_BIT & INTER_IN) == 0) {
   1889          				SoftUART_SetReceiveByte();
   1890          				
   1891          			}else{
   1892          				//
   1893          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1894          				DCOCTL =  CALDCO_1MHZ;
   1895          				//
   1896          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	                // Period T(us) * F(MHz)
   1897          				//
   1898          				continue;		                                // False pulse
   1899          			}
   1900          			sh = 0x01;
   1901          			byte = 0;
   1902          			while (sh) {
   1903          				if (fTimerA_On) {
   1904          					fTimerA_On = 0;
   1905          					//
   1906          					//CH_IN_SET();
   1907          					//CH_IN_CLR();
   1908          					//
   1909          					if (INTER_BIT & INTER_IN) {
   1910          						byte |= sh;
   1911          					}
   1912          					sh <<= 1;
   1913          				}
   1914          			}
   1915          			// Receive byte
   1916          			SoftUART_ResetReceiveByte();
   1917          			//
   1918          			if (uart_rx_ind == 0) {
   1919          				// Begin of packet
   1920          				len = packet_len_table[byte];
   1921          				if (len > UART_BUF_LEN) {
   1922          					len = UART_BUF_LEN;
   1923          				}
   1924          			}
   1925          				
   1926          			*(uart_rx_buf+uart_rx_ind++) = byte;
   1927          			if (uart_rx_ind >= len) {
   1928          				// Parse of packet
   1929          				//...
   1930          				SoftUART_RxParse();
   1931          				INTER_IFG &= ~INTER_BIT;    				// Обнуляем флаг прерывания
   1932          				fRxLineDownOn = 0;
   1933          			}else{
   1934          				//			
   1935          				uart_timer = 4;								// 200 ms timeout to next byte
   1936          				while (1) {
   1937          					//__bis_SR_register(LPM3_bits + GIE);     // Enter LPM3
   1938          					//
   1939          					while ((fRxLineDownOn || fTimer50msOn) == 0) {}
   1940          					//
   1941          					if (fRxLineDownOn) {
   1942          						goto label_rx_continue;
   1943          					}
   1944          					if (fTimer50msOn) {						// Получен следующий 50мс интервал
   1945          						fTimer50msOn = 0;
   1946          						//
   1947          						if (uart_timer) {
   1948          							uart_timer--;
   1949          						}else{
   1950          							// End of Rx timeout
   1951          							//...
   1952          							INTER_IFG &= ~INTER_BIT;    	// Обнуляем флаг прерывания
   1953          							fRxLineDownOn = 0;
   1954          							break;
   1955          						}
   1956          					}
   1957          				}
   1958          			}
   1959          			//
   1960          			//
   1961          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1962          			DCOCTL =  CALDCO_1MHZ;
   1963          			//
   1964          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1965          			//
   1966          
   1967                             //
   1968          		} // Soft UART Rx Hundler
   1969          	} // while(1)
   1970          }
   1971          
   1972          
   1973          
   1974          
   1975          //--------------------------------------------------------------------------------
   1976          // Function		: __interrupt void watchdog_timer (void)
   1977          // Parameters	: None
   1978          // Return		: None
   1979          // Description	: WDT Interrupt routine
   1980          //--------------------------------------------------------------------------------
   1981          #pragma vector=WDT_VECTOR
   1982          __interrupt void watchdog_timer (void) {
   1983          	
   1984          	if (fTimer50msOn) {
   1985          		if (++Timer50msCounter == 0) {		// > ~ 12sec
   1986          //			WDTCTL = WDTCTL;				// Hardware RESET
   1987          		}
   1988          	}
   1989          	fTimer50msOn = 1;
   1990          	
   1991          //	__bic_SR_register_on_exit(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
   1992                  LPM3_EXIT;
   1993          }
   1994          
   1995          
   1996          
   1997          //--------------------------------------------------------------------------------
   1998          // Function		: __interrupt void CCR0_ISR(void)
   1999          // Parameters	: None
   2000          // Return		: None
   2001          // Description	: TIMER0 Interrupt routine
   2002          //--------------------------------------------------------------------------------
   2003          #pragma vector = TIMER0_A0_VECTOR
   2004          __interrupt void CCR0_ISR(void) {
   2005                    fTimerA_On = 1;
   2006          	
   2007          } // CCR0_ISR
   2008          
   2009          #pragma vector = TIMER0_A1_VECTOR
   2010          __interrupt void CCR_ISR(void) {
   2011                  TEST_OUT_SET();
   2012          } // CCR0_ISR
   2013          
   2014          
   2015          //--------------------------------------------------------------------------------
   2016          // Function		: __interrupt void Timer_A1_ISR (void)
   2017          // Parameters	: None
   2018          // Return		: None
   2019          // Description	: TIMER1 Interrupt routine
   2020          //--------------------------------------------------------------------------------
   2021          #pragma vector=TIMER1_A0_VECTOR
   2022          __interrupt void Timer_A1_ISR (void)  {
   2023          	
   2024          	fTimerA1_On = 1;
   2025          
   2026          	//__bic_SR_register_on_exit(LPM0_bits);                   // Clear LPM3 bits from 0(SR)
   2027          } 
   2028          
   2029          
   2030          
   2031          //--------------------------------------------------------------------------------
   2032          // Function		: void Led_Flash(u16 duration)
   2033          // Parameters	: duration - duration Red LED flash in ms
   2034          // Return		: None
   2035          // Description	: Flashing red LED
   2036          //--------------------------------------------------------------------------------
   2037          void Led_Flash(u16 duration) {
   2038                  IRED_SET();
   2039                  DelayUs(100);
   2040          	IRED_CLR();
   2041                  
   2042                  RED_SET();
   2043                  YEL_SET();
   2044          	DelayMs(duration);
   2045                  RED_CLR();
   2046                  YEL_CLR();
   2047          }
   2048          
   2049          //--------------------------------------------------------------------------------
   2050          // Function		: void VREF_On(void)
   2051          // Parameters	: None 
   2052          // Return		: None
   2053          // Description	: Enable VREF
   2054          //--------------------------------------------------------------------------------
   2055          void VREF_On(void) {
   2056          
   2057          	ADC10CTL0 = REFOUT + REFON + SREF_1 + MSC + ADC10ON;
   2058          	ADC10AE0 |= 0x10;                         // P1.4 ADC option select (VRef Out)
   2059          
   2060          }
   2061          
   2062          
   2063          
   2064          //--------------------------------------------------------------------------------
   2065          // Function		: void VREF_Off(void)
   2066          // Parameters	: None
   2067          // Return		: None
   2068          // Description	: Disable VREF
   2069          //--------------------------------------------------------------------------------
   2070          void VREF_Off(void) {
   2071          
   2072          	ADC10CTL0 = 0;							// Disable ADC & +VREF
   2073          	ADC10CTL0 = 0;							//
   2074          }
   2075          
   2076          
   2077          
   2078          //--------------------------------------------------------------------------------
   2079          // Function		: void ADC10_ISR(void)
   2080          // Parameters	: None
   2081          // Return		: None
   2082          // Description	: ADC10 interrupt service routine
   2083          //--------------------------------------------------------------------------------
   2084          #pragma vector=ADC10_VECTOR
   2085          __interrupt void ADC10_ISR(void) {
   2086          
   2087          	//ADC10AE0 &= ~0x0F;                      // Save only VRef Out
   2088          	
   2089          	adc_process = 0;
   2090          	
   2091          	fEndOfSamples = 1;
   2092                  
   2093          	//__bic_SR_register_on_exit(CPUOFF);      // Clear CPUOFF bit from 0(SR)
   2094          	
   2095          }
   2096          
   2097          
   2098          
   2099          //--------------------------------------------------------------------------------
   2100          // Function		: u16 AverageData(u16 * data_ptr, u8 len)
   2101          // Parameters	: data_ptr - data array pointer, len - length of data array
   2102          // Return		: Average value of data
   2103          // Description	: Fuction calculate the average value of data array
   2104          //--------------------------------------------------------------------------------
   2105          u16 AverageData(u16 * data_ptr, u8 len) {
   2106          	u16 summa = 0;
   2107          	u8  i = len;
   2108          	while (i--) {
   2109          		summa += *data_ptr++;
   2110          	}
   2111          	//
   2112          	return (summa/len);
   2113          }
   2114          
   2115          
   2116          //--------------------------------------------------------------------------------
   2117          // Function		: void DeviceDiagnostics(void)
   2118          // Parameters	: None
   2119          // Return		: None
   2120          // Description	: Procedure of the diagnostics device
   2121          //--------------------------------------------------------------------------------
   2122          void DeviceDiagnostics(void) {
   2123          	//
   2124          	DelayMs(100);
   2125          	//
   2126          	//
   2127          		
   2128          #if (1 == CRC_ENABLE)
   2129          	// Check CS of Memory
   2130          	DeviceFault.fFaultCRC = 0;
   2131          	if (GetPropertiesCS() != CONFIG->CS) {
   2132          		DeviceFault.fFaultCRC = 1;
   2133          	}
   2134          #endif
   2135          }
   2136          
   2137          //--------------------------------------------------------------------------------
   2138          // Function		: u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count)
   2139          // Parameters	: refout = 0 or REFOUT, vref = REF1_5V , count - кол-во измерений 
   2140          // Return		: None
   2141          // Description	: Measurement of the current temperature of MCU
   2142          //--------------------------------------------------------------------------------
   2143          #pragma optimize=none
   2144          u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count) {
   2145          	u16 res;
   2146          
   2147          	while(adc_process) {}
   2148          	
   2149          	BUT_IE &= ~BUT_BIT;
   2150          	BUT_REN &= ~BUT_BIT; 		// PULL disable
   2151          	
   2152          	ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC  + ADC10ON + ADC10IE;	// Sample&hold = 8 x ADC10CLKs
   2153          	
   2154          	DelayUs(50);	
   2155          	//
   2156          	ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ch;	// ADC_BUT;     // 
   2157          	//
   2158          	DelayUs(200);							// Delay to allow Ref to settle
   2159          
   2160          	ADC10DTC1 = count;						// count of conversions
   2161          	ADC10AE0 = ADC_AE_BUT;                 // A3 & A7 ADC option select
   2162          	//
   2163          	ADC10SA = (u16) &buf[0];          		// Data buffer start
   2164          	
   2165          	fEndOfSamples = 0;
   2166          	ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
   2167          		
   2168          	__bis_SR_register(CPUOFF + GIE);        // LPM0, ADC10_ISR will force exit
   2169          	
   2170          	while (fEndOfSamples == 0){};
   2171          	fEndOfSamples = 0;
   2172          
   2173          	res = AverageData(buf, count);	
   2174          
   2175          	ADC10AE0 = ADC_AE;          // A3 & A7 ADC option select
   2176          	
   2177          	BUT_IFG &= ~BUT_BIT;    	// Обнуляем флаг прерывания
   2178          	BUT_IE |= BUT_BIT;
   2179          	BUT_REN |= BUT_BIT; 		// PULL enable
   2180          	
   2181          	return res;
   2182          }
   2183          
   2184          
   2185          //--------------------------------------------------------------------------------
   2186          // Function		: void u8 JP1_Define(void)
   2187          // Parameters	: None
   2188          // Return		: 0 - JP1 Open, 1 - JP1 Close
   2189          // Description	: Definition of JP1 state
   2190          //--------------------------------------------------------------------------------
   2191          void JP1_Define(void) {
   2192          	u16 buf[4];
   2193          	u16 temp;
   2194          	
   2195          	temp = ADC_Measure_Simple(ADC_BUT, buf, 4);
   2196          	
   2197          	if (temp > 600) return; 
   2198          	if (temp > 100) {
   2199          		jp1_state = 0;		// JP1 is Open 
   2200          	}else{
   2201          		jp1_state = 1;		// JP1 is Close
   2202          	}	
   2203          	//
   2204          	return;	
   2205          }
   2206          
   2207          
   2208          // End of main.c

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   ADC10_ISR
      4   ADC_MeasureInit
        4   -> DelayUs
      2   ADC_MeasureStart
     10   ADC_Measure_Simple
       10   -> AverageData
       10   -> DelayUs
       10 ?Epilogue4
      2   ADC_SetParam
      2   AMP_Gain_Init
        0   -> AMP_SetGain
      2   AbsValue
      4   AverageData
        4 ?DivMod16u
      4   CCR0_ISR
      4   CCR_ISR
     22   CalibrationResultAnalise
       22   -> AMP_SetGain
       22   -> SavePropertyCS
       22   -> SetLevelsFromCalibr
       22   -> SetLimitCompens
       22   -> StoragePropertyByte
       22   -> StoragePropertyWord
       14 ?Epilogue6
      2   ClearDriftVar
      2   DeviceDiagnostics
        2   -> DelayMs
        2   -> GetPropertiesCS
      2   DeviceStart
        2   -> ClearDriftVar
        2   -> GetPropertiesCS
      2   FaultSignalManager
     10   JP1_Define
       10   -> ADC_Measure_Simple
      2   LedTestValueManager
      4   Led_Flash
        4   -> DelayMs
        4   -> DelayUs
      2   SetFaultMode
      6   SetLevels
        6   -> ClearDriftVar
        6   -> SavePropertyCS
        6   -> StoragePropertyWord
        6 ?DivMod16s
        6 ?DivMod16u
      6   SetLevelsFromCalibr
        6   -> ClearDriftVar
        6   -> SavePropertyCS
        6   -> StoragePropertyWord
        6 ?DivMod16u
      2   SetLimitCompens
        0   -> ClearDriftVar
        2   -> SavePropertyCS
        2   -> StoragePropertyWord
     28   SignalAnalysis
       28   -> AverageData
       28   -> fir_filter
       28 ?ClearMemoryBytes
       28 ?DivMod16s
       14 ?Epilogue6
      2   TimerA1_DelayUs
      2   Timer_A0_Off
      2   Timer_A0_SetDelay
      2   Timer_A0_SetPWMPulse
      4   Timer_A0_StartPWM
        4 ?DivMod16u
      2   Timer_A0_StopPWM
      4   Timer_A1_ISR
      2   Timer_A1_Init
      2   VREF_Off
      2   VREF_On
      8   fir_filter
        8 ?DivMod32s
        8 ?Epilogue3
        8 ?Mul16to32s
        8 ?ShiftRight32s_9
      2   getTimerValue
      2   getZeroLevel
        0 ?DivMod16u
     12   main
       12   -> ADC_MeasureInit
       12   -> ADC_MeasureStart
       12   -> ADC_SetParam
       12   -> AMP_SetGain
       12   -> CalibrationResultAnalise
       12   -> ClearDriftVar
       12   -> DelayMs
       12   -> DelayUs
       12   -> DelayUs_8MHz
       12   -> DeviceStart
       12   -> FaultSignalManager
       12   -> GPIO_Init
       12   -> JP1_Define
       12   -> LedTestValueManager
       12   -> Led_Flash
       12   -> SetFaultMode
       12   -> SetLevels
       12   -> SignalAnalysis
       12   -> SoftUART_ResetReceiveByte
       12   -> SoftUART_RxParse
       12   -> SoftUART_SetReceiveByte
       12   -> SoftUART_TxString
       12   -> Timer_A0_Off
       12   -> Timer_A0_SetDelay
       12   -> Timer_A0_StartPWM
       12   -> Timer_A0_StopPWM
       12   -> Timer_A1_Init
       12   -> getTimerValue
       12   -> getZeroLevel
       12 ?DivMod16u
       12 ?DivMod32u
      4   watchdog_timer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       7  ?<Constant {0, 0, 0, 0, 0, 0, 0}>
       7  ?<Constant {0, 0, 0, 0, 0, 0, 0}>_1
       1  ?<Initializer for jp1_state>
       1  ADC10AE0
       2  ADC10CTL0
       2  ADC10CTL1
       1  ADC10DTC1
       2  ADC10SA
      10  ADC10_ISR
       2  ADC10_ISR::??INTVEC 10
      88  ADC_MeasureInit
      24  ADC_MeasureStart
     140  ADC_Measure_Simple
      36  ADC_SetParam
       8  AMP_Gain_Init
      14  AbsValue
      30  AverageData
       1  BCSCTL1
       1  BCSCTL3
       1  CALBC1_16MHZ
       1  CALBC1_1MHZ
       1  CALBC1_8MHZ
       1  CALDCO_16MHZ
       1  CALDCO_1MHZ
       1  CALDCO_8MHZ
       4  CCR0_ISR
       2  CCR0_ISR::??INTVEC 18
       2  CCR1_Value
       8  CCR_ISR
       2  CCR_ISR::??INTVEC 16
       1  CalibrFault
     418  CalibrationResultAnalise
      22  ClearDriftVar
       1  DCOCTL
      32  DeviceDiagnostics
       1  DeviceFault
       1  DeviceMode
      30  DeviceStart
       2  DriftCounter
       4  DriftLevel
       4  DriftSumma
      18  FIRCoef
     296  FaultSignalManager
       1  IE1
       1  IFG1
      36  JP1_Define
     132  LedTestValueManager
      54  Led_Flash
       1  P1IE
       1  P1IFG
       1  P1OUT
       1  P1REN
       1  P1SEL
       1  P2DIR
       1  P2IFG
       1  P2IN
       1  P2OUT
       2  PWM_period
      24  SetFaultMode
      94  SetLevels
     162  SetLevelsFromCalibr
      24  SetLimitCompens
     582  SignalAnalysis
       2  TA0CCR0
       2  TA0CCR1
       2  TA0CCTL0
       2  TA0CCTL1
       2  TA0CTL
       2  TA0R
       2  TA1CCR0
       2  TA1CCTL0
       2  TA1CTL
       2  TA1R
       1  Timer50msCounter
      40  TimerA1_DelayUs
      30  Timer_A0_Off
      42  Timer_A0_SetDelay
      22  Timer_A0_SetPWMPulse
      94  Timer_A0_StartPWM
      26  Timer_A0_StopPWM
       6  Timer_A1_ISR
       2  Timer_A1_ISR::??INTVEC 26
      28  Timer_A1_Init
      10  VREF_Off
      14  VREF_On
       2  WDTCTL
      32  adc_data1
       1  adc_process
       1  amp_no
      18  calibr_sequence
       1  calibr_stage
       2  cfg_reg
       2  d1
       2  d2
       2  d3
       2  d4
       2  dark
       2  delta
       2  delta_last
       2  f
       1  fTimerA1_On
       1  fault_chain_ind
       2  fault_chain_timer
       1  fault_chamber_counter
       1  fault_phase
       8  fault_sequence
       2  fault_timer
     114  fir_filter
       2  flash_period_timer
       1  gain
      30  getTimerValue
      12  getZeroLevel
       2  hi_signal_counter
       1  jp1_state
       2  last_0_level
       2  last_level
       4  led_r
       4  led_sh
       4  led_y
       1  light_sync
       2  light_timer
    2420  main
       1  prevDeviceFault
       1  prevDeviceMode
       6  q_array
       1  reference
      12  s_array
     200  signal_array
       2  start_timer
       1  strob_fault_phase
       2  strob_pulse_timer
       2  timerKeyDown
       2  timerMain
      18  watchdog_timer
       2  watchdog_timer::??INTVEC 20
      36  x
       2  zero_timer

 
 5 174 bytes in segment CODE
    50 bytes in segment DATA16_AN
    58 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
   369 bytes in segment DATA16_Z
    10 bytes in segment INTVEC
     2 bytes in segment REGVAR_AN
 
 5 174 bytes of CODE     memory
    59 bytes of CONST    memory (+ 10 bytes shared)
   370 bytes of DATA     memory (+ 50 bytes shared)
     0 bytes of REGISTER memory (+  2 bytes shared)

Errors: none
Warnings: 7
